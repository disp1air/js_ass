 * Высота блока не может быть задана с помощью процентов; высота блока всегда принимает значение высоты контента, если только не задана абсолютная высота, например, в пикселях или em;
 * Границы также не могут быть заданы в процентах.
 * полная ширина блока включет в себя сумму свойств width, padding-right, padding-left, border-right и border-left. В некоторых случаях это может быть неудобно (для примера когда нужно чтобы вся ширина блока была равна строго 50% включая границы и внутренние отступы заданные в пикселях). Для того чтобы избежать таких проблем, необходимо настроить блочную модель используя свойство box-sizing. Значение border-box меняет блочную модель следующим образом.

**в CSS как свойства, так и их значения не чувствительны к регистру**

Если свойство неизвестно или приписанное значение не является допустимым для данного свойства, то все объявление считается недопустимым и полностью игнорируется движком браузера.

Если в цепочке или группе есть хотя бы один ошибочный селектор, что бывает, например, при использовании неизвестного псевдо-элемента или псевдо-класса, то вся эта цепочка или группа считается ошибочной и игнорируется.

При перезагрузке веб-страницы браузер не всегда перезагружает данные, уже находящиеся в кэше, в том числе внешние таблицы стилей. Таким образом, невозможно увидеть, как выглядит веб-страница, стилизованная с помощью только что отредактированного CSS-кода из внешней таблицы стилей.  

Есть два пути решения этой проблемы: выключить кэширование или заставить браузер перезагрузить все содержимое веб-страницы. Чтобы обойти эту путаницу, можно выполнить принудительную перезагрузку страницы: Ctrl + F5.

Золотое правило - добавлять стили до js.

добавляя таблицы стилей первыми, вы гарантируете, что код JavaScript будет располагать всей необходимой для своего выполнения информацией.

Можно прикрепить таблицу стилей к веб-странице с помощью HTML-тега <link> или встроенного в CSS правила @import, которое делает то же самое. Правило @import может сделать одну вещь, с которой тег <link> не справится, — присоединить одну внешнюю таблицу стилей к другой.  

### Связывание таблиц стилей с HTML-кодом:
Для всех типов документов необходимы два атрибута:
 * rel="stylesheet" — указывает тип ссылки; в данном случае это ссылка на таблицу стилей;
 * href — задает местонахождение внешнего CSS-файла на сайте.

### Прикрепление таблиц стилей с использованием CSS
CSS имеет встроенный способ привязки внешних таблиц стилей к коду HTML — правило @import. Его нужно добавить в HTML-тег <style>. Например:  
                                        
                                        <style type="text/css">
                                            @import url(css/styles.css);
                                        </style>

В отличие от HTML-тега правило @import — языковая конструкция CSS, обладающая некоторыми несвойственными HTML качествами.

 * Чтобы выполнить привязку к внешнему файлу CSS, нужно использовать url вместо href и заключать путь к CSS-файлу в круглые скобки. Так, в рассмотренном выше примере css/styles.css — путь к внешнему CSS-файлу. Кавычки, в которые заключен URL, не обязательны. Таким образом, url(css/styles.css) и url("css/styles.css") будут работать одинаково.
 * Посредством нескольких правил @import, как и с помощью нескольких тегов, можно присоединить любое количество внешних таблиц стилей:  

                                        <style type="text/css">
                                            @import url(css/styles.css);
                                            @import url(css/forms.css);
                                        </style>  

 * После правила @import можно добавлять обычные CSS-стили

                                        <style type="text/css">
                                            @import url(css/styles.css);
                                            @import url(css/forms.css);
                                            p { color:red; }
                                        </style>  

Нужно поместить все правила @import перед CSS-стилями, как показано в примере. Веб-браузеры игнорируют любые таблицы стилей, импортируемые после CSS-правила, поэтому если изменить порядок показанного выше кода на обратный и стиль p появится первым, то браузер проигнорирует любые стили в таблицах стилей style.css или form.css.

#### именование классов:  
 * при именовании стилевых классов разрешается использование только букв алфавита, чисел, дефисов, знаков подчеркивания.  
 * Название после точки всегда должно начинаться с символа — буквы алфавита. Например, .9lives — неправильное имя класса, а .crazy8 — правильное. Можно называть классы, например, именами .copy-right и .banner_image, но не .-bad или ._as_bad.  
 * Имена стилевых классов чувствительны к регистру. Например, .SIDEBAR и .sidebar рассматриваются языком CSS по-разному, как различные классы.  

### Ограничения наследования
Многие CSS-свойства вообще не наследуются, например border.
Ниже описаны конкретные случаи, когда наследование точно не применяется:

 * Как правило, свойства, которые затрагивают размещение элементов на странице (отступы (поля), границы (рамки) элементов), не наследуются. Было бы не очень приятно, если бы у body был отступ и его наследовали все элементы вложенные в body.  

**Единственный способ перекрыть инструкцию !important - это включить в исходный код другую инструкцию !important с такой же специфичностью, но позднее.**

Специфичность измеряет то, селектор специфичен — то есть скольким элементам он может соответствовать.

Величину специфичности селектора измеряют согласно четырем разным величинам (или компонентам), которые можно представить как тысячи, сотни, десятки и единицы — четыре цифры в четырех столбцах:  
 * Тысячи: Ставит единицу в этот столбец, если селектор внутри элемента <style> или объявление находится внутри атрибута style (такие объявления не имеют селекторов, и их специфичность всегда равна 1000.) В противном случае ставьте 0.
 * Сотни: Добавляет единицу в этот столбец за каждый селектор ID, содержащийся внутри составного селектора.
 * Десятки: Добавляет единицу в этот столбец за каждый селектор класса, атрибута или псевдо-класса, содержащийся в составном селекторе.
 * Единицы: Добавляет единицу в этот столбец за каждый селектор элемента или псевдо-элемента, содержащийся в составном селекторе.

**Примечание: Универсальный селектор(*), комбинаторы (+, >, ~, ' ') и псевдо-класс отрицания (:not) на специфичность не влияют.**

### margin collapse  
Вертикальные смежные margin-ы схлопываются. Если два элемента имеют положительный вертикальный отступ, то в результате отступом между элементами будет наибольший из двух отступов.(за исключением случая, когда последнему элементу применено свойство clear).  

**отступы плавающих и абсолютно (и относительно) позиционированных элементов никогда не схлопываются.**  

Если один элемент имеет положительный отступ, а второй отрицательный, то результатом будет сумма отступов между элементами.  

Если сумма отступов будет отрицательной, то последний элемент будет перекрывать первый.  

Если родительский элемент не имеет border или padding, тогда родительский и дочерний отступ схлопнутся и результатом будет больший из двух отступов.

Чтобы убрать схлопывание, нужно задать для родительского элемента border или padding.


**ширину border нельзя использовать в процентах**  

### Префиксы производителей  
Чтобы пометить CSS-свойство как экспериментальное или еще не до конца согласованное, производители браузеров используют префикс, который ставится перед названием свойства. Обычно, если W3C CSS Working Group принимает свойство и в достаточной степени завершает его детализацию, производители отказываются от префикса.  

Процентные значения свойства ширины width рассчитываются на основании ширины элемента-контейнера. Если вы установите ширину заголовка равной 75 %, и этот заголовок не вложен ни в какие другие элементы веб-страницы с явно определенной шириной, то ширина текста заголовка составит 75 % от ширины окна браузера. Если посетитель изменит размер окна браузера, то ширина заголовка тоже изменится. Однако если заголовок заключен в блок <div> шириной 200 пикселов, то ширина данного заголовка составит 150 пикселов.  

!!!???Процентные значения в свойстве высоты height работают точно так же, но расчет базируется на высоте элемента-контейнера, а не на его ширине.  

### Наследование стилей. Свойства inset, initial, inherit  
Значение **initial** применяется для установки исходного значения свойства. Может восстановить значения свойств, заданных браузером по умолчанию или задать начальное значение свойства, измененное в результате наследования.  

**inherit** - ключевое слово, которое сообщает, что необходимо наследовать значение свойства у родительского элемента. Естественно, результат будет заметен только в том случае, если у родителя указанное свойство установлено.  

The unset CSS keyword resets a property to its inherited value if it inherits from its parent, and to its initial value if not. In other words, it behaves like the inherit keyword in the first case, and like the initial keyword in the second case.  

https://developer.mozilla.org/en-US/docs/Web/CSS/unset  


### Перемещение  
Функция translate свойства transform просто перемещает элемент из его текущей позиции на некоторое расстояние вправо или влево и вверх или вниз.  

Функции translate передаются два значения: первое определяет величину горизонтального, а второе — вертикального перемещения. Чтобы элемент переместился влево, нужно для первого значения использовать отрицательное число, применение отрицательного числа в качестве второго значения приведет к перемещению элемента вверх.  

В CSS3 предоставляются также две дополнительные функции для перемещения элемента только влево или вправо — translateX и только вверх или вниз —translateY. Например, для перемещения элемента вверх на .5em используется функция translateY:

                                        transform: translateY(-.5em);

### наклон  
Наклон элемента можно осуществить по его горизонтальной и вертикальной осям. Например, для наклона всех вертикальных линий влево на 45°, нужно написать следующий код:

                                        transform: skew(45deg, 0);

Первое значение задает угол от 0deg до 360deg для всех вертикальных линий, действующий в направлении против часовой стрелки.

Второе значение задает угол от 0deg до 360deg для всех горизонтальных линий, действующий в направлении по часовой стрелке.

Как и в случае с translate и scale, в CSS3 предлагаются отдельные функции для осей X и Y: skewX и skewY.

