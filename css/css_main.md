 * Высота блока не может быть задана с помощью процентов; высота блока всегда принимает значение высоты контента, если только не задана абсолютная высота, например, в пикселях или em;
 * Границы также не могут быть заданы в процентах.
 * полная ширина блока включет в себя сумму свойств width, padding-right, padding-left, border-right и border-left. В некоторых случаях это может быть неудобно (для примера когда нужно чтобы вся ширина блока была равна строго 50% включая границы и внутренние отступы заданные в пикселях). Для того чтобы избежать таких проблем, необходимо настроить блочную модель используя свойство box-sizing. Значение border-box меняет блочную модель следующим образом.

**в CSS как свойства, так и их значения не чувствительны к регистру**

Если свойство неизвестно или приписанное значение не является допустимым для данного свойства, то все объявление считается недопустимым и полностью игнорируется движком браузера.

Если в цепочке или группе есть хотя бы один ошибочный селектор, что бывает, например, при использовании неизвестного псевдо-элемента или псевдо-класса, то вся эта цепочка или группа считается ошибочной и игнорируется.

При перезагрузке веб-страницы браузер не всегда перезагружает данные, уже находящиеся в кэше, в том числе внешние таблицы стилей. Таким образом, невозможно увидеть, как выглядит веб-страница, стилизованная с помощью только что отредактированного CSS-кода из внешней таблицы стилей.  

Есть два пути решения этой проблемы: выключить кэширование или заставить браузер перезагрузить все содержимое веб-страницы. Чтобы обойти эту путаницу, можно выполнить принудительную перезагрузку страницы: Ctrl + F5.

Золотое правило - добавлять стили до js.

добавляя таблицы стилей первыми, вы гарантируете, что код JavaScript будет располагать всей необходимой для своего выполнения информацией.

Можно прикрепить таблицу стилей к веб-странице с помощью HTML-тега <link> или встроенного в CSS правила @import, которое делает то же самое. Правило @import может сделать одну вещь, с которой тег <link> не справится, — присоединить одну внешнюю таблицу стилей к другой.  

### Связывание таблиц стилей с HTML-кодом:
Для всех типов документов необходимы два атрибута:
 * rel="stylesheet" — указывает тип ссылки; в данном случае это ссылка на таблицу стилей;
 * href — задает местонахождение внешнего CSS-файла на сайте.

### Прикрепление таблиц стилей с использованием CSS
CSS имеет встроенный способ привязки внешних таблиц стилей к коду HTML — правило @import. Его нужно добавить в HTML-тег <style>. Например:  
                                        
                                        <style type="text/css">
                                            @import url(css/styles.css);
                                        </style>

В отличие от HTML-тега правило @import — языковая конструкция CSS, обладающая некоторыми несвойственными HTML качествами.

 * Чтобы выполнить привязку к внешнему файлу CSS, нужно использовать url вместо href и заключать путь к CSS-файлу в круглые скобки. Так, в рассмотренном выше примере css/styles.css — путь к внешнему CSS-файлу. Кавычки, в которые заключен URL, не обязательны. Таким образом, url(css/styles.css) и url("css/styles.css") будут работать одинаково.
 * Посредством нескольких правил @import, как и с помощью нескольких тегов, можно присоединить любое количество внешних таблиц стилей:  

                                        <style type="text/css">
                                            @import url(css/styles.css);
                                            @import url(css/forms.css);
                                        </style>  

 * После правила @import можно добавлять обычные CSS-стили

                                        <style type="text/css">
                                            @import url(css/styles.css);
                                            @import url(css/forms.css);
                                            p { color:red; }
                                        </style>  

Нужно поместить все правила @import перед CSS-стилями, как показано в примере. Веб-браузеры игнорируют любые таблицы стилей, импортируемые после CSS-правила, поэтому если изменить порядок показанного выше кода на обратный и стиль p появится первым, то браузер проигнорирует любые стили в таблицах стилей style.css или form.css.

#### именование классов:  
 * при именовании стилевых классов разрешается использование только букв алфавита, чисел, дефисов, знаков подчеркивания.  
 * Название после точки всегда должно начинаться с символа — буквы алфавита. Например, .9lives — неправильное имя класса, а .crazy8 — правильное. Можно называть классы, например, именами .copy-right и .banner_image, но не .-bad или ._as_bad.  
 * Имена стилевых классов чувствительны к регистру. Например, .SIDEBAR и .sidebar рассматриваются языком CSS по-разному, как различные классы.  

### Ограничения наследования
Многие CSS-свойства вообще не наследуются, например border.
Ниже описаны конкретные случаи, когда наследование точно не применяется:

 * Как правило, свойства, которые затрагивают размещение элементов на странице (отступы (поля), границы (рамки) элементов), не наследуются. Было бы не очень приятно, если бы у body был отступ и его наследовали все элементы вложенные в body.  

**Единственный способ перекрыть инструкцию !important - это включить в исходный код другую инструкцию !important с такой же специфичностью, но позднее.**

Специфичность измеряет то, селектор специфичен — то есть скольким элементам он может соответствовать.

Величину специфичности селектора измеряют согласно четырем разным величинам (или компонентам), которые можно представить как тысячи, сотни, десятки и единицы — четыре цифры в четырех столбцах:  
 * Тысячи: Ставит единицу в этот столбец, если селектор внутри элемента <style> или объявление находится внутри атрибута style (такие объявления не имеют селекторов, и их специфичность всегда равна 1000.) В противном случае ставьте 0.
 * Сотни: Добавляет единицу в этот столбец за каждый селектор ID, содержащийся внутри составного селектора.
 * Десятки: Добавляет единицу в этот столбец за каждый селектор класса, атрибута или псевдо-класса, содержащийся в составном селекторе.
 * Единицы: Добавляет единицу в этот столбец за каждый селектор элемента или псевдо-элемента, содержащийся в составном селекторе.

**Примечание: Универсальный селектор(*), комбинаторы (+, >, ~, ' ') и псевдо-класс отрицания (:not) на специфичность не влияют.**

### margin collapse  
Вертикальные смежные margin-ы схлопываются. Если два элемента имеют положительный вертикальный отступ, то в результате отступом между элементами будет наибольший из двух отступов.(за исключением случая, когда последнему элементу применено свойство clear).  

**отступы плавающих и абсолютно (и относительно) позиционированных элементов никогда не схлопываются.**  

Если один элемент имеет положительный отступ, а второй отрицательный, то результатом будет сумма отступов между элементами.  

Если сумма отступов будет отрицательной, то последний элемент будет перекрывать первый.  

Если родительский элемент не имеет border или padding, тогда родительский и дочерний отступ схлопнутся и результатом будет больший из двух отступов.

Чтобы убрать схлопывание, нужно задать для родительского элемента border или padding.

