### Links :books:
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise  
https://habr.com/company/mailru/blog/269465/  
https://learn.javascript.ru/fetch  
https://learn.javascript.ru/promise  

                                    let promise = applyForVisa();

Т.к. applyForVisa это асинхронная функция, то она вернет обещание.

                                    promise.then(resolve, reject);

у обещания есть метод then(), данный метод принимает два аргумента:
 - resolve - функция которая сработает, если обещание выполняется(если промис переходит в состояние resolved)
 - reject - функция которая сработает, если обещание не будет выполнено(если промис переходит в состояние rejected)

promise.then(bookHotel, cancelVacation);

т.к. applyForVisa вернет обещание, то можно сразу записать таким образом:
                                    
                                    applyForVisa()
                                        .then(resolve, reject)
                                        
В метод then не обязательно отправлять два аргумента, достаточно отправлять только один, на тот случай если обещание будет выполнено.

Если же обещание не будет выполнено, то мы можем использовать другой метод у объекта promise:

                                    applyForVisa()
                                        .then(resolve)
                                        .catch(reject)

then - Добавляет обработчик выполнения и отклонения обещания, и **возвращает новое обещание** выполненное со значением вызванного обработчика, или оригинальное значение, если обещание не было обработано (т.е. если соответствующий обработчик onFulfilled или onRejected не является функцией).

после метода catch можно использовать еще один then 

                                    applyForVisa()
                                        .then(resolve)
                                        .catch(reject)
                                        .then(() => console.log('111'))

И эта функция, которую передали в последний then, выполнится в любом случае - была ли ошибка или не было ошибки

не забывать возвращать данные из функции, которую передаем в метод then(но это при условии если они нужны в следующем then)

Выражение

new Promise((resolve, reject) => {
    resolve();
});

равносильно выражению

Promise.resolve();

промис - некоторый объект-контейнер для будущего состояния. Может переходить в состояния только один раз.

Статические методы конструктора Promise(example 4)
если нужно создать промис и сразу его зарезолвить то Promise.resolve();  

### Chaining promises  
Функция которая используется как первый колбэк может возвращать какие-то данные и эти данные  можно передать на вход следующей функции. Но если эта функция передает промис, то на вход следующего колбэка приходит значение этого промиса. (см. example 6.js)

### Error handling  
Если ошибка возникает в первом колбэке метода then() то во второй колбэк этого метода then() мы естественно как и ошибка не попадаем. (см. example error_handling/7.js)

### Cleanup a promise
Метод finally принимает колбэк без параметров и этот колбэк срабатывает в любом случае вне зависимости от того в какое состояние перешел промис. Используется для каких-то очисток, обнулений которые нужно сделать после того как промис перешел в какое-то состояние. 

finally возвращает промис и никак не влияет на то, что было до него  

                                    Promise.resolve(2)
                                        .finally(() => {})
                                        .then(v => console.log(v));

В этом случае 2 попадает в then и успешно выводится в консоль  

### Executing Asynchronous Functions in Parallel  
При использовании Promise.all в первый колбэк метода then() попадает массив значений которые резолвятся с помощью соответствующих промисов  

метод race() - работает по принципу первый всегда прав - если первым будет resolve - то ресолвится с этим значением, если первый reject - то реджектится с этим значением.

Если же имеется два промиса которые зарезолвятся через одинаковое время, то при вызове метода race() зарезолвится тот промис, который который зарегистрирован в коде раньше (пример race_3.js)

### "Проваливание" сквозь промисы  

                                    Promise.resolve(1)
                                        .then(Promise.resolve(2))
                                        .then(data => console.log(data)); // 1

когда в then() передается что-то отличное от функции (например, промис), это интерпретируется как then(null) и в следующий по цепочке промис «проваливается» результат предыдущего.
