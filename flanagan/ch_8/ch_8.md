## Функции
Поскольку функции являются объектами, имеется возможность присваивать значения их свойствам и даже вызывать их методы.

Определение функций выполняется с помощью ключевого слова function, которое может использоваться в выражениях определения функций или в инструкциях объявления функций.

Имя является обязательной частью инструкции объявления функции: оно будет использовано для создания новой переменной,
которой будет присвоен объект новой функции.

инструкции объявления функций «поднимаются» в начало сценария или вмещающей их функции, благодаря чему объявленные
таким способом функции могут вызываться в программном коде выше объявления. Это не относится к функциям, которые
определяются в виде выражений: чтобы вызвать функцию, необходимо иметь возможность сослаться на нее, однако нельзя
сослаться на функцию, которая определяется с помощью выражения, пока она не будет присвоена переменной. Объявления
переменных также поднимаются вверх, но операции присваивания значений этим переменным не поднимаются, поэтому функции, определяемые в виде выражений, не могут вызываться до того, как они будут определены.

### вызов методов
Выражения вызова методов могут включать более сложные выражения обращения к свойствам:

                            customer.surname.toUpperCase(); // Вызвать метод объекта customer.surname
                            f().m(); // Вызвать метод m() возвращаемого значения функции f()

Если вложенная функция вызывается как метод, значением this является объект, относительно которого был сделан вызов.
Если вложенная функция вызывается как функция, то значением this будет либо глобальный объект.

Распространенная ошибка полагать что во вложенной функции, которая вызывается как функция, можно использовать this для получения доступа к контексту внешней функции. Если во вложенной функции необходимо иметь доступ к значению this внешней функции, это значение следует сохранить в переменной, находящейся в области видимости внутренней функции.
Для этой цели часто используется переменная с именем self. Например:

                            var o = { // Объект o.
                                m: function() { // Метод m объекта.
                                    var self = this; // Сохранить значение this в переменной.
                                    console.log(this === o); // Выведет "true": this - это объект o.
                                    f(); // Вызвать вспомогательную ф-цию f().
                                    
                                    function f() { // Вложенная функция f
                                        console.log(this === o); // "false": this - глоб. об. или undefined
                                        console.log(self === o); // "true": self - знач. this внеш. ф-ции.
                                    }
                                }
                            };
                            o.m(); // Вызвать метод m объекта o.

### Вызов конструкторов
При вызове конструктора всегда можно опустить пару **пустых** скобок.

                                                var o = new Object();
                                                var o = new Object;

Вызов конструктора создает новый пустой объект, наследующий свойство prototype конструктора. Назначение функции-
конструктора – инициализировать объект, и этот вновь созданный объект передается конструктору как контекст вызова,
благодаря чему функция-конструктор может ссылаться на него с помощью ключевого слова this. Обратите внимание,
что вновь созданный объект передается как контекст вызова, даже если вызов конструктора выглядит как вызов метода.
То есть в выражении new o.m() контекстом вызова будет вновь созданный объект, а не объект o.

Как правило, в функциях-конструкторах не используется инструкция return. Обычно они выполняют инициализацию нового
объекта и неявно возвращают его, по достижении своего конца. В этом случае значением выражения вызова конструктора
становится новый объект. Однако если конструктор явно вернет объект с помощью инструкции return, то значением выражения вызова конструктора станет этот объект. Если конструктор выполнит инструкцию return без значения или вернет
с ее помощью простое значение, это возвращаемое значение будет проигнорировано и в качестве результата вызова
будет использован новый объект.

### косвенный вызов
Функции в языке JavaScript являются объектами и подобно другим объектам имеют свои методы. В их числе есть два метода,
call() и apply(), выполняющие косвенный вызов функции. Оба метода позволяют явно определить значение this для вызываемой функции, что дает возможность вызывать любую функцию как метод любого объекта, даже если фактически она не является методом этого объекта. Кроме того, обоим методам можно передать аргументы вызова. Метод call() позволяет передавать аргументы для вызываемой функции в своем собственном списке аргументов, а метод apply() принимает массив
значений, которые будут использованы как аргументы. 

### Аргументы и параметры функций
Когда число аргументов в вызове функции меньше числа объявленных параметров, недостающие аргументы получают значение
undefined.

### Объект Arguments
Если число аргументов в вызове функции превышает число имен параметров, функция лишается возможности напрямую
обращаться к неименованным значениям. Решение этой проблемы предоставляет объект Arguments. В теле функции
идентификатор arguments ссылается на объект Arguments.

Объект Arguments – это объект, подобный массиву, позволяющий извлекать переданные функции значения по их номерам, а не по именам.

                                        AO = {
                                            arguments: {
                                                callee: ... , // ссылка на выполняемую функцию
                                                length: ... , // кол-во реально переданных параметров
                                                свойства-индексы
                                            }
                                        }

Предположим, что была определена функция f, которая требует один аргумент, x. Если вызвать эту функцию с двумя аргументами, то первый будет доступен внутри функции по имени параметра x или как arguments[0]. Второй аргумент будет
доступен только как arguments[1]. Кроме того, подобно настоящим массивам, arguments имеет свойство length, определяющее количество содержащихся элементов(т.е. реально переданных).

Не следует забывать, что arguments фактически не является массивом – это объект Arguments. В каждом объекте
Arguments имеются пронумерованные элементы массива и свойство length, но с технической точки зрения это не массив.
Лучше рассматривать его как объект, имеющий некоторые пронумерованные свойства.

У объекта Arguments есть одна очень необычная особенность. Когда у функции имеются именованные параметры,
элементы массива объекта Arguments при выполнении в нестрогом режиме являются синонимами параметров, содержащих
аргументы функции. Массив arguments[] и имена параметров – это два разных средства обращения к одним и тем же переменным. Изменение значения аргумента через имя аргумента меняет значение, извлекаемое через массив arguments[].
Изменение значения аргумента через массив arguments[] меняет значение, извлекаемое по имени аргумента.

                                    function f(x) {
                                        console.log(x);         // Выведет начальное значение аргумента
                                        arguments[0] = null;    // При изменении элемента массива изменяется x!
                                        console.log(x);         // Теперь выведет "null"
                                    }

Эта особенность в поведении объекта Arguments была ликвидирована в строгом режиме, предусматриваемом
стандартом ECMAScript 5.
В строгом режиме не допускается использовать имя arguments в качестве имени параметра или локальной переменной
функции и отсутствует возможность присваивать значения элементам arguments.

### Свойства callee и caller
Объект Arguments также определяет свойства callee и caller. При попытке изменить значения этих свойств в строгом
режиме ECMAScript 5 гарантированно возбуждается исключение TypeError.

Свойство callee ссылается на выполняемую в данный момент функцию.
Свойство caller не является стандартным, но оно присутствует во многих реализациях и ссылается на функцию, вызвавшую
текущую. Свойство caller можно использовать для доступа к стеку вызовов, а свойство callee особенно удобно 
использовать для рекурсивного вызова неименованных функций:

                                            var factorial = function(x) {
                                                if (x <= 1) return 1;
                                                return x * arguments.callee(x-1);
                                            };

### Определение собственных свойств функции
Когда функции требуется «статическая » переменная, значение которой должно сохраняться между ее вызовами, часто
оказывается удобным использовать свойство объекта функции.

                                        Инициализировать свойство counter объекта функции.
                                        Объявления функций поднимаются вверх, поэтому мы можем
                                        выполнить это присваивание до объявления функции.
                                        uniqueInteger.counter = 0;

                                        function uniqueInteger() {
                                            return uniqueInteger.counter++; // Увеличить и вернуть свойство counter
                                        }


