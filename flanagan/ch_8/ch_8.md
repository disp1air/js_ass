## Функции
Поскольку функции являются объектами, имеется возможность присваивать значения их свойствам и даже вызывать их методы.

Определение функций выполняется с помощью ключевого слова function, которое может использоваться в выражениях определения функций или в инструкциях объявления функций.

Имя является обязательной частью инструкции объявления функции: оно будет использовано для создания новой переменной,
которой будет присвоен объект новой функции.

инструкции объявления функций «поднимаются» в начало сценария или вмещающей их функции, благодаря чему объявленные
таким способом функции могут вызываться в программном коде выше объявления. Это не относится к функциям, которые
определяются в виде выражений: чтобы вызвать функцию, необходимо иметь возможность сослаться на нее, однако нельзя
сослаться на функцию, которая определяется с помощью выражения, пока она не будет присвоена переменной. Объявления
переменных также поднимаются вверх, но операции присваивания значений этим переменным не поднимаются, поэтому функции, определяемые в виде выражений, не могут вызываться до того, как они будут определены.

### вызов методов
Выражения вызова методов могут включать более сложные выражения обращения к свойствам:

                            customer.surname.toUpperCase(); // Вызвать метод объекта customer.surname
                            f().m(); // Вызвать метод m() возвращаемого значения функции f()

Если вложенная функция вызывается как метод, значением this является объект, относительно которого был сделан вызов.
Если вложенная функция вызывается как функция, то значением this будет либо глобальный объект.

Распространенная ошибка полагать что во вложенной функции, которая вызывается как функция, можно использовать this для получения доступа к контексту внешней функции. Если во вложенной функции необходимо иметь доступ к значению this внешней функции, это значение следует сохранить в переменной, находящейся в области видимости внутренней функции.
Для этой цели часто используется переменная с именем self. Например:

                            var o = { // Объект o.
                                m: function() { // Метод m объекта.
                                    var self = this; // Сохранить значение this в переменной.
                                    console.log(this === o); // Выведет "true": this - это объект o.
                                    f(); // Вызвать вспомогательную ф-цию f().
                                    
                                    function f() { // Вложенная функция f
                                        console.log(this === o); // "false": this - глоб. об. или undefined
                                        console.log(self === o); // "true": self - знач. this внеш. ф-ции.
                                    }
                                }
                            };
                            o.m(); // Вызвать метод m объекта o.

### Вызов конструкторов
При вызове конструктора всегда можно опустить пару **пустых** скобок.

                                                var o = new Object();
                                                var o = new Object;

Вызов конструктора создает новый пустой объект, наследующий свойство prototype конструктора. Назначение функции-
конструктора – инициализировать объект, и этот вновь созданный объект передается конструктору как контекст вызова,
благодаря чему функция-конструктор может ссылаться на него с помощью ключевого слова this. Обратите внимание,
что вновь созданный объект передается как контекст вызова, даже если вызов конструктора выглядит как вызов метода.
То есть в выражении new o.m() контекстом вызова будет вновь созданный объект, а не объект o.

Как правило, в функциях-конструкторах не используется инструкция return. Обычно они выполняют инициализацию нового
объекта и неявно возвращают его, по достижении своего конца. В этом случае значением выражения вызова конструктора
становится новый объект. Однако если конструктор явно вернет объект с помощью инструкции return, то значением выражения вызова конструктора станет этот объект. Если конструктор выполнит инструкцию return без значения или вернет
с ее помощью простое значение, это возвращаемое значение будет проигнорировано и в качестве результата вызова
будет использован новый объект.

### косвенный вызов
Функции в языке JavaScript являются объектами и подобно другим объектам имеют свои методы. В их числе есть два метода,
call() и apply(), выполняющие косвенный вызов функции. Оба метода позволяют явно определить значение this для вызываемой функции, что дает возможность вызывать любую функцию как метод любого объекта, даже если фактически она не является методом этого объекта. Кроме того, обоим методам можно передать аргументы вызова. Метод call() позволяет передавать аргументы для вызываемой функции в своем собственном списке аргументов, а метод apply() принимает массив
значений, которые будут использованы как аргументы. 

### Аргументы и параметры функций
Когда число аргументов в вызове функции меньше числа объявленных параметров, недостающие аргументы получают значение
undefined.

### Объект Arguments
Если число аргументов в вызове функции превышает число имен параметров, функция лишается возможности напрямую
обращаться к неименованным значениям. Решение этой проблемы предоставляет объект Arguments. В теле функции
идентификатор arguments ссылается на объект Arguments.

Объект Arguments – это объект, подобный массиву, позволяющий извлекать переданные функции значения по их номерам, а не по именам.

                                        AO = {
                                            arguments: {
                                                callee: ... , // ссылка на выполняемую функцию
                                                length: ... , // кол-во реально переданных параметров
                                                свойства-индексы
                                            }
                                        }

Предположим, что была определена функция f, которая требует один аргумент, x. Если вызвать эту функцию с двумя аргументами, то первый будет доступен внутри функции по имени параметра x или как arguments[0]. Второй аргумент будет
доступен только как arguments[1]. Кроме того, подобно настоящим массивам, arguments имеет свойство length, определяющее количество содержащихся элементов(т.е. реально переданных).

Не следует забывать, что arguments фактически не является массивом – это объект Arguments. В каждом объекте
Arguments имеются пронумерованные элементы массива и свойство length, но с технической точки зрения это не массив.
Лучше рассматривать его как объект, имеющий некоторые пронумерованные свойства.

У объекта Arguments есть одна очень необычная особенность. Когда у функции имеются именованные параметры,
элементы массива объекта Arguments при выполнении в нестрогом режиме являются синонимами параметров, содержащих
аргументы функции. Массив arguments[] и имена параметров – это два разных средства обращения к одним и тем же переменным. Изменение значения аргумента через имя аргумента меняет значение, извлекаемое через массив arguments[].
Изменение значения аргумента через массив arguments[] меняет значение, извлекаемое по имени аргумента.

                                    function f(x) {
                                        console.log(x);         // Выведет начальное значение аргумента
                                        arguments[0] = null;    // При изменении элемента массива изменяется x!
                                        console.log(x);         // Теперь выведет "null"
                                    }

Эта особенность в поведении объекта Arguments была ликвидирована в строгом режиме, предусматриваемом
стандартом ECMAScript 5.
В строгом режиме не допускается использовать имя arguments в качестве имени параметра или локальной переменной
функции и отсутствует возможность присваивать значения элементам arguments.

### Свойства callee и caller
Объект Arguments также определяет свойства callee и caller. При попытке изменить значения этих свойств в строгом
режиме ECMAScript 5 гарантированно возбуждается исключение TypeError.

Свойство callee ссылается на выполняемую в данный момент функцию.
Свойство caller не является стандартным, но оно присутствует во многих реализациях и ссылается на функцию, вызвавшую
текущую. Свойство caller можно использовать для доступа к стеку вызовов, а свойство callee особенно удобно 
использовать для рекурсивного вызова неименованных функций:

                                            var factorial = function(x) {
                                                if (x <= 1) return 1;
                                                return x * arguments.callee(x-1);
                                            };

### Определение собственных свойств функции
Когда функции требуется «статическая » переменная, значение которой должно сохраняться между ее вызовами, часто
оказывается удобным использовать свойство объекта функции.

                                        Инициализировать свойство counter объекта функции.
                                        Объявления функций поднимаются вверх, поэтому мы можем
                                        выполнить это присваивание до объявления функции.
                                        uniqueInteger.counter = 0;

                                        function uniqueInteger() {
                                            return uniqueInteger.counter++; // Увеличить и вернуть свойство counter
                                        }

### функции как пространство имен
Иногда бывает удобно определять функции, которые играют роль временного пространства имен, где можно объявлять
переменные, не засоряя глобальное пространство имен.

Предположим, что имеется модуль JavaScript, который можно использовать в различных программах. Допустим, что в программном коде этого модуля, объявляются переменные. Проблема состоит в том, могут возникать конфликты между переменными, создаваемыми модулем, и переменными, используемыми в программах, импортирующих этот модуль. Решение состоит в том, чтобы поместить программный код модуля в функцию и затем вызыватьэту функцию. При таком подходе переменные модуля из глобальных превратятся в локальные переменные функции.

                                            (function() { 
                                                // Здесь находится реализация модуля.
                                            }());

### замыкания

### Свойства и методы функций
В теле функции свойство arguments.length определяет количество аргументов, переданных функции. Однако свойство
length самой функции имеет иной смысл. Это свойство, доступное только для чтения, возвращает количество аргументов,
которое функция ожидает получить, – число объявленных параметров.

arguments.length - число фактически переданных аргументов.
arguments.callee.length - число ожидаемых аргументов.

                            // Эта функция использует arguments.callee, поэтому она
                            // не будет работать в строгом режиме.
                            function check(args) {
                                var actual = args.length;          // Фактическое число аргументов
                                var expected = args.callee.length; // Ожидаемое число аргументов
                                if (actual !== expected) // Если не совпадают, генерируется исключение
                                    throw new Error("ожидается: " + expected + "; получено " + actual);
                            }

### Методы call() и apply()
Первым аргументом обоим методам, call() и apply(), передается объект, относительно которого вызывается функция;
этот аргумент определяет контекст вызова и становится значением ключевого слова this в теле функции.
Чтобы вызвать функцию f() (без аргументов) как метод объекта o, можно использовать любой из методов, call() или apply():

                                                    f.call(o);
                                                    f.apply(o);

В строгом режиме ECMAScript 5 первый аргумент методов call() и apply() становится значением this, даже если
это простое значение, null или undefined.

Все остальные аргументы метода call(), следующие за первым аргументом, определяющим контекст вызова,
передаются вызываемой функции.

                                                    f.call(o, 1, 2);

Метод apply() действует подобно методу call(), за исключением того, что аргументы для функции передаются
в виде массива:

                                                    f.apply(o, [1,2]);

метод apply() может работать не только с настоящими массивами, но и с объектами, подобными массивам.

### метод bind()
Если вызвать метод bind() функции f и передать ему объект o, он вернет новую функцию. Вызов новой функции
(как обычной функции) выполнит вызов оригинальной функции f как метода объекта o. Любые аргументы, переданные
новой функции, будут переданы оригинальной функции.

                            function f(y) { return this.x + y; } // Функция, которую требуется привязать
                            var o = { x : 1 }; // Объект, к которому выполняется привязка
                            var g = f.bind(o); // Вызов g(x) вызовет o.f(x)
                            g(2) // => 3

Метод bind() в ECMAScript 5 не просто связывает функцию с объектом. Он также выполняет частичное применение:
помимо значения this связаны будут все аргументы, переданные методу bind() после первого его аргумента.

                            var sum = function(x,y) { return x + y }; 
                            // Создать новую функцию, подобную sum, но со связанным значением null
                            // ключевого слова this и со связанным значением первого аргумента, равным 1.
                            // Новая функция принимает всего один аргумент.
                            var succ = sum.bind(null, 1);
                            succ(2) // => 3: аргумент x связан со значением 1, а 2 передается в арг. y

                            function f(y,z) { return this.x + y + z };
                            var g = f.bind({x:1}, 2); // Связать this и y
                            g(3) // => 6: this.x - связан с 1, y - связан с 2, а 3 передается в z

Метод bind(), имеет некоторые особенности:
 * метод bind() возвращает объект функции, свойство length которой установлено в соответствии с количеством
параметров связываемой функции, минус количество связанных аргументов (но не меньше нуля).

 * метод bind() в ECMAScript 5 может использоваться для частичного применения функций-конструкторов.
Если функцию, возвращаемую методом bind(), использовать как конструктор, значение this, переданное методу
bind(), игнорируется, и оригинальная функция будет вызвана как конструктор, с уже связанными аргументами,
если они были определены.

Функции, возвращаемые методом bind(), не имеют свойства prototype (свойство prototype обычных функций
нельзя удалить), и объекты, созданные связанными функциями-конструкторами, наследуют свойство prototype
оригинального, несвязанного конструктора.

Кроме того, с точки зрения оператора instanceof связанные конструкторы действуют точно так же, как несвязанные конструкторы.