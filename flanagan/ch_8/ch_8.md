## Функции
Поскольку функции являются объектами, имеется возможность присваивать значения их свойствам и даже вызывать их методы.

Определение функций выполняется с помощью ключевого слова function, которое может использоваться в выражениях определения функций или в инструкциях объявления функций.

Имя является обязательной частью инструкции объявления функции: оно будет использовано для создания новой переменной,
которой будет присвоен объект новой функции.

инструкции объявления функций «поднимаются» в начало сценария или вмещающей их функции, благодаря чему объявленные
таким способом функции могут вызываться в программном коде выше объявления. Это не относится к функциям, которые
определяются в виде выражений: чтобы вызвать функцию, необходимо иметь возможность сослаться на нее, однако нельзя
сослаться на функцию, которая определяется с помощью выражения, пока она не будет присвоена переменной. Объявления
переменных также поднимаются вверх, но операции присваивания значений этим переменным не поднимаются, поэтому функции, определяемые в виде выражений, не могут вызываться до того, как они будут определены.

### вызов методов
Выражения вызова методов могут включать более сложные выражения обращения к свойствам:

                            customer.surname.toUpperCase(); // Вызвать метод объекта customer.surname
                            f().m(); // Вызвать метод m() возвращаемого значения функции f()

Если вложенная функция вызывается как метод, значением this является объект, относительно которого был сделан вызов.
Если вложенная функция вызывается как функция, то значением this будет либо глобальный объект.

Распространенная ошибка полагать что во вложенной функции, которая вызывается как функция, можно использовать this для получения доступа к контексту внешней функции. Если во вложенной функции необходимо иметь доступ к значению this внешней функции, это значение следует сохранить в переменной, находящейся в области видимости внутренней функции.
Для этой цели часто используется переменная с именем self. Например:

                            var o = { // Объект o.
                                m: function() { // Метод m объекта.
                                    var self = this; // Сохранить значение this в переменной.
                                    console.log(this === o); // Выведет "true": this - это объект o.
                                    f(); // Вызвать вспомогательную ф-цию f().
                                    
                                    function f() { // Вложенная функция f
                                        console.log(this === o); // "false": this - глоб. об. или undefined
                                        console.log(self === o); // "true": self - знач. this внеш. ф-ции.
                                    }
                                }
                            };
                            o.m(); // Вызвать метод m объекта o.

### Вызов конструкторов
При вызове конструктора всегда можно опустить пару **пустых** скобок.

                                                var o = new Object();
                                                var o = new Object;

Вызов конструктора создает новый пустой объект, наследующий свойство prototype конструктора. Назначение функции-
конструктора – инициализировать объект, и этот вновь созданный объект передается конструктору как контекст вызова,
благодаря чему функция-конструктор может ссылаться на него с помощью ключевого слова this. Обратите внимание,
что вновь созданный объект передается как контекст вызова, даже если вызов конструктора выглядит как вызов метода.
То есть в выражении new o.m() контекстом вызова будет вновь созданный объект, а не объект o.

Как правило, в функциях-конструкторах не используется инструкция return. Обычно они выполняют инициализацию нового
объекта и неявно возвращают его, по достижении своего конца. В этом случае значением выражения вызова конструктора
становится новый объект. Однако если конструктор явно вернет объект с помощью инструкции return, то значением выражения вызова конструктора станет этот объект. Если конструктор выполнит инструкцию return без значения или вернет
с ее помощью простое значение, это возвращаемое значение будет проигнорировано и в качестве результата вызова
будет использован новый объект.

### косвенный вызов
Функции в языке JavaScript являются объектами и подобно другим объектам имеют свои методы. В их числе есть два метода,
call() и apply(), выполняющие косвенный вызов функции. Оба метода позволяют явно определить значение this для вызываемой функции, что дает возможность вызывать любую функцию как метод любого объекта, даже если фактически она не является методом этого объекта. Кроме того, обоим методам можно передать аргументы вызова. Метод call() позволяет передавать аргументы для вызываемой функции в своем собственном списке аргументов, а метод apply() принимает массив
значений, которые будут использованы как аргументы. 

### Аргументы и параметры функций
Когда число аргументов в вызове функции меньше числа объявленных параметров, недостающие аргументы получают значение
undefined.