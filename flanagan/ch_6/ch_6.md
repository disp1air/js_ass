## Объекты
Имена свойств являются строками.

Помимо собственных свойств объекты могут также наследовать свойства от других объектов, известных под названием «прототипы».

Свойство имеет имя и значение. Именем свойства может быть идентификатор или любая строка, включая и пустую строку, но объект не может
иметь два свойства с одинаковыми именами.

Значением свойства может быть любое значение, допустимое в языке.

каждое свойство имеет ряд ассоциированных с ним значений, которые называют атрибутами свойства:
 * Атрибут **writable** определяет доступность значения свойства для записи.
 * Атрибут **enumerable** определяет доступность имени свойства для перечисления в цикле for/in.
 * Атрибут **configurable** определяет возможность настройки, т. е. удаления свойства и изменения его атрибутов.

 В дополнение к свойствам каждый объект имеет три атрибута объекта:
 * Атрибут **prototype** содержит ссылку на другой объект, от которого наследуются свойства.
 * Атрибут **class** содержит строку с именем класса объекта и определяет тип объекта.
 * Флаг **extensible** указывает на возможность добавления новых свойств в объект.

три обширные категории объектов в языке JavaScript:
 * Объект базового языка – это объект или класс объектов, определяемый спецификацией ECMAScript. Массивы, функции,
   даты и регулярные выражения (например) являются объектами базового языка.
 * Объект среды выполнения – это объект, определяемый средой выполнения (такой как веб-броузер), куда встроен           интерпретатор JavaScript. Объекты HTMLElement, представляющие структуру веб-страницы в клиентском JavaScript,
   являются объектами среды выполнения.
 * Пользовательский объект – любой объект, созданный в результате выполнения программного кода JavaScript.

пример создания объектов:

                    var book = {
                        "main title": "JavaScript",           // Имена свойств с пробелами
                        'sub-title': "The Definitive Guide",  // и дефисами, поэтому используются строковые литералы
                        "for": "all audiences",               // for - зарезервированное слово, поэтому в кавычках
                        author: {                             // Значением этого свойства является объект
                            firstname: "David",               // имена этих свойств без кавычек.
                            surname: "Flanagan"
                        }
                    };

Литерал объекта – это выражение, которое создает и инициализирует новый объект всякий раз, когда производится
вычисление этого выражения. Значение каждого свойства вычисляется заново, когда вычисляется значение литерала.
Это означает, что с помощью единственного литерала объекта можно создать множество новых объектов, если этот литерал
поместить в тело цикла или функции, которая будет вызываться многократно.

**Все объекты, созданные с помощью литералов объектов, имеют один и тот же объект-прототип, на который в программе JavaScript можно сослаться так: Object.prototype**

### Object.create()
Object.create() - создает новый объект и использует свой первый аргумент в качестве прототипа этого объекта.
Дополнительно Object.create() может принимать второй необязательный аргумент, описывающий свойства нового объекта.

Чтобы создать объект, не имеющий прототипа, можно передать значение null, но в этом случае вновь созданный объект
не унаследует ни каких-либо свойств, ни базовых методов.

Если потребуется создать обычный пустой объект (который, например, возвращается литералом {} или выражением
new Object()), передайте в первом аргументе Object.prototype:

    var o3 = Object.create(Object.prototype); // o3 подобен объекту, созданному с помощью {} или new Object().

### получение и изменение свойств
При использовании оператора точки справа должен находиться простой идентификатор, соответствующий имени свойства.
При использовании квадратных скобок в квадратных скобках должно указываться выражение, возвращающее строку (или значение, которое может быть преобразовано в строку) содержащую имя требуемого свойства:

                            var title = book["main title"] // Получить свойство "main title" объекта book.

Стандарт ECMAScript 5 ослабляет допускает возможность использования зарезервированных слов после оператора точки.

Объекты в языке JavaScript являются ассоциативными массивами.

обращения к свойству оператора точка (.) имя свойства определяется идентификатором. Идентификаторы должны вводиться
в тексте программы буквально – это не тип данных, поэтому в программе невозможно реализовать вычисление дентификаторов.

Напротив, когда для обращения к свойствам объекта используется форма записи с квадратными скобками ([]), имя свойства
определяется строкой. Строки в языке JavaScript являются типом данных, поэтому они могут создаваться и изменяться
в ходе выполнения программы. Благодаря этому, например, в языке JavaScript имеется возможность писать такой программный код:

                                        var addr = "";
                                        for(i = 0; i < 4; i++)
                                            addr += customer["address" + i] + '\n

Этот фрагмент читает и объединяет в одну строку значения свойств address0, address1, address2 и address3 объекта customer.

Если на момент создания программы имена свойств нам неизвестны, мы не можем использовать оператор точки (.) для доступа к свойствам объекта. Однако мы можем задействовать оператор [], потому что для обращения к свойствам он позволяет использовать строковые значения (которые являются динамическими и могут изменяться во время выполнения)
вместо идентификаторов (которые являются статическими и должны жестко определяться в тексте программы).

### ошибки доступа к свойствам
Попытка присвоить значение свойству p объекта o потерпит неудачу в следующих случаях:
 * Объект o имеет собственное свойство p, доступное только для чтения: нельзя изменить значение свойства, доступного
   только для чтения. (Обратите, однако, внимание на метод defineProperty(), который представляет собой исключение,
   позволяющее изменять значения настраиваемых свойств, доступных только для чтения.)
 * Объект o имеет унаследованное свойство p, доступное только для чтения: унаследованные свойства, доступные
   только для чтения, невозможно переопределить собственными свойствами с теми же именами.
 * Объект o не имеет собственного свойства p; объект o не наследует свойство p с методами доступа и атрибут             extensible объекта o имеет значение false. Если свойство p отсутствует в объекте o и для него не определен      метод записи, то операция присваивания попытается добавить свойство p в объект o. Но поскольку объект o    не        допускает возможность расширения, то попытка добавить в него новое свойство потерпит неудачу.

### удаление свойств
Оператор delete не удаляет ненастраиваемые свойства, атрибут configurable которых имеет значение false. (Однако
он может удалять настраиваемые свойства нерасширяемых объектов.) Ненастраиваемыми являются свойства встроенных
объектов, а также свойства глобального объекта, созданные с помощью инструкций объявления переменных и функций. 

### проверка существования свойств.
Метод hasOwnProperty() объекта проверяет, имеет ли объект собственное свойство с указанным именем.
Для наследуемых свойств он возвращает false:

                                        var o = { x: 1 }
                                        o.hasOwnProperty("x"); // true: o имеет собственное свойство x
                                        o.hasOwnProperty("y"); // false: не имеет свойства y
                                        o.hasOwnProperty("toString"); // false: toString - наследуемое свойство

Метод propertyIsEnumerable() накладывает дополнительные ограничения по сравнению с hasOwnProperty(). Он возвращает
true, только если указанное свойство является собственным свойством, атрибут enumerable которого имеет значение
true. Свойства встроенных объектов не являются перечислимыми.

Часто вместо оператора in достаточно использовать простое выражение обращения к свойству и использовать оператор
!== для проверки на неравенство значению undefined:

                                        var o = { x: 1 }
                                        o.x !== undefined; // true: o имеет свойство x
                                        o.y !== undefined; // false: o не имеет свойства y
                                        o.toString !== undefined; // true: o наследует свойство toString

Оператор in отличает отсутствие свойства от свойства, имеющего значение undefined:

                                var o = { x: undefined }      // Свойству явно присвоено значение undefined 
                                o.x !== undefined             // false: свойство имеется,но со значением undefined 
                                o.y !== undefined             // false: свойство не существует 
                                "x" in o                      // true: свойство существует 
                                "y" in o                      // false: свойство не существует
                                delete o.x;                   // Удалить свойство x
                                "x" in o                      // false: оно больше не существует 

### перечисление свойств
Встроенные методы, наследуемые объектами, являются неперечислимыми, а свойства, добавляемые в объекты вашей программой, являются перечислимыми (если только не использовались функции, описываемые ниже, позволяющие сделать
свойства неперечислимыми).
Инструкция цикла for/in выполняет тело цикла для каждого перечислимого свойства(собственного или унаследованного).

Возвращает массив имен собственных перечислимых свойств объекта o.
function keys(o) {
    if (typeof o !== "object") throw TypeError(); // Арг. должен быть объектом
    var result = [];        // Возвращаемый массив
    for(var prop in o) {    // Для всех перечислимых свойств
        if (o.hasOwnProperty(prop)) // Если это собственное свойство,
            result.push(prop); // добавить его в массив array.
    }
    return result; // Вернуть массив.
}

Object.keys() - возвращает массив имен собственных перечислимых свойств объекта. Она действует аналогично
функции keys()
Object.getOwnPropertyNames() - действует подобно функции Object.keys(), но возвращает имена всех собственных свойств указанного объекта, а не только перечислимые.

### методы чтения и записи свойств
значение может замещаться одним или двумя методами, известными как методы чтения (getter) и записи (setter). Свойства,
для которых определяются методы чтения и записи, иногда называют свойствами с методами доступа.

В отличие от свойств с данными, свойства с методами доступа не имеют атрибута writable. Если свойство имеет оба метода, чтения и записи, оно доступно для чтения/записи. Если свойство имеет только метод чтения, оно доступно только
для чтения. А если свойство имеет только метод записи, оно доступно только для записи (такое невозможно для свойств с данными) и попытки прочитать значение такого свойства всегда будут возвращать undefined.

### атрибуты свойств
Помимо имени и значения свойства обладают атрибутами, определяющими их доступность для записи, перечисления и настройки.

Таким образом, свойства имеют имя и четыре атрибута. Четырьмя атрибутами свойств с данными являются:
 * значение (value),
 * признак доступности для записи (writable),
 * признак доступности для перечисления (enumerable),
 * признак доступности для настройки (configurable).
 
В свойствах с методами доступа отсутствуют атрибуты value и writable: их доступность для записи определяется
наличием или отсутствием метода записи. Поэтому четырьмя атрибутами свойств с методами доступа являются:
 * метод чтения (get),
 * метод записи (set),
 * признак доступности для перечисления (enumerable)
 * признак доступности для настройки (configurable).

Методы получения и записи значений атрибутов свойств, предусмотренные стандартом ECMAScript 5, используют объект,
называемый дескриптором свойства (property descriptor), представляющий множество из четырех атрибутов. Объект
дескриптора свойства обладает свойствами, имена которых совпадают с именами атрибутов свойства, которое он описывает.
То есть объекты-дескрипторы свойств с данными имеют свойства с именами value, writable, enumerable и configurable.
А дескрипторы свойств с методами доступа вместо свойств value и writable имеют свойства get и set. Свойства writable, enumerable и configurable являются логическими значениями, а свойства get и set – функциями.

Получить дескриптор свойства требуемого объекта можно вызовом Object.getOwnPropertyDescriptor():

                                    // Вернет {value: 1, writable:true, enumerable:true, configurable:true}
                                    Object.getOwnPropertyDescriptor({x:1}, "x");

                                    // Вернет undefined для унаследованных и несуществующих свойств.
                                    Object.getOwnPropertyDescriptor({}, "x"); // undefined, нет такого свойства
                                    Object.getOwnPropertyDescriptor({}, "toString"); // undefined, унаследованное


Object.getOwnPropertyDescriptor() работает только с собственными свойствами. Чтобы получить атрибуты унаследованного
свойства, необходимо явно выполнить обход цепочки прототипов (Object.getPrototypeOf())
