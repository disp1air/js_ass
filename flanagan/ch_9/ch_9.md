## Классы и модули

Классы в языке JavaScript основаны на использовании механизма наследования прототипов.
Если два объекта наследуют свойства от одного и того же объекта-прототипа, говорят, что они принадлежат
одному классу.

Если два объекта наследуют один и тот же прототип, обычно (но не обязательно) это означает,
что они были созданы и инициализированы с помощью одного конструктора.

важной особенностью классов в языке JavaScript является возможность динамического расширения.

### Классы и конструкторы
Применение ключевого слова **new** при вызове конструктора автоматически создает новый объект,
(этот объект доступен в конструкторе как значение this) поэтому конструктору остается только
инициализировать свойства этого нового объекта.

другая формулировка - оператор new создает новый объект и вызывает функцию-конструктор для инициализации
свойств этого объекта. Также объекту добавляется свойство [[prototype]] указывающее на prototype функции-конструктора.

Важной особенностью вызова конструктора является использование свойства prototype конструктора
в качестве прототипа нового объекта. Это означает, что все объекты, созданные с помощью одного конструктора, наследуют один и тот же объект-прототип и, соответственно, являются членами одного и того же класса.

Новый объект создается автоматически перед вызовом конструктора и доступен в конструкторе как значение this. Конструкторы даже не должны возвращать вновь созданный объект.Выражение вызова конструктора автоматически создает новый объект, вызывает конструктор как метод этого объекта и возвращает объект.

### Конструкторы и идентификация класса
Два объекта являются экземплярами одного класса, только если они наследуют один и тот же объект-прототип.
Функция-конструктор, инициализирующая свойства нового объекта, не является определяющей: два конструктора
могут иметь свойства prototype, ссылающиеся на один объект-прототип. В этом случае оба конструктора
будут создавать экземпляры одного и того же класса.

Конструкторы выступают в качестве фасада класса. Например, имя конструктора обычно используется в качестве
имени класса.

Однако более важным применением конструкторов является их использование в операторе instanceof при проверке
принадлежности объекта классу. Если имеется объект r, и необходимо проверить, является ли он объектом
класса Range, такую проверку можно выполнить так:

                            r instanceof Range // вернет true, если r наследует Range.prototype

В действительности оператор instanceof не проверяет, был ли объект r инициализирован конструктором Range. Он проверяет, наследует ли этот объект свойство Range.prototype.

### свойство constructor
Роль конструктора в языке JavaScript может играть любая функция, поскольку выражению вызова конструктора
необходимо лишь свойство prototype. **Следовательно, любая функция (кроме функций, возвращаемых методом Function.bind()) автоматически получает свойство prototype. Это свойство prototype создается сразу же как мы определяем функцию. Значением этого свойства является объект, который имеет единственное неперечислимое свойство constructor.Значением свойства constructor является объект функции:**

                                        var F = function() {}; // Это объект функции.
                                        var p = F.prototype; // Это объект-прототип, связанный с ней.
                                        var c = p.constructor; // Это функция, связанная с прототипом.
                                        c === F // => true: F.prototype.constructor === F для всех функций

Наличие предопределенного объекта-прототипа со свойством constructor означает, что объекты обычно наследуют свойство
constructor, которое ссылается на их конструкторы. Поскольку конструкторы играют роль идентификаторов классов,
свойство constructor определяет класс объекта:

                                        var o = new F(); // Создать объект класса F
                                        o.constructor === F // => true: свойство constructor определяет класс

### оператор instanceof
Слева от оператора должен находиться объект, для которого выполняется проверка принадлежности к классу, а справа
– имя функции-конструктора, представляющей класс. Выражение o instanceof c возвращает true, если объект o наследует
c.prototype. При этом наследование необязательно может быть непосредственным. Если o наследует объект, который
наследует объект, наследующий c.prototype, выражение все равно вернет true.

Несмотря на то что в операторе instanceof используется функция-конструктор, этот оператор в действительности
проверяет прототип, наследуемый объектом, а не конструктор, с помощью которого он был создан.

Если необходимо проверить, входит ли некоторый определенный прототип в цепочку прототипов объекта без использования
функции-конструктора, как промежуточного звена, можно воспользоваться методом isPrototypeOf(). Например, ниже показано, как проверить принадлежность объекта r к классу range:

                                    range.methods.isPrototypeOf(r); // range.methods - объект-прототип.

### duck-typing
Когда я вижу птицу, которая ходит, как утка, плавает, как утка и крякает, как утка, я называю ее уткой.
Для программистов на языке JavaScript этот афоризм можно интерпретировать так:

«Если объект может ходить, плавать и крякать как объект класса Duck, его можно считать объектом класса
Duck, даже если он не наследует объект-прототип класса Duck».
