Выражение – это фраза языка JavaScript, которая может быть вычислена интерпретатором для получения значения. Константа, встроенная в программу, является простейшей разновидностью выражений. Имя переменной также является простейшим выражением, в результате вычисления которого получается значение, присвоенное переменной.

### Первичные выражения
Простейшие выражения, известные как первичные выражения, являются самостоятельными выражениями – они не включают
более простых выражений.

Первичными выражениями в языке JavaScript являются константы, или литералы, некоторые ключевые слова и ссылки на переменные.

Литералы и константы встраиваются непосредственно в программный код. Они выглядят, как показано ниже:

                                    1.23 // Числовой литерал
                                    "hello" // Строковый литерал
                                    /pattern/ // Литерал регулярного выражения

Ниже приводятся некоторые из зарезервированных слов JavaScript, являющихся первичными выражениями:

                                    true // Возвращает логическое значение true
                                    false // Возвращает логическое значение false
                                    null // Возвращает значение null
                                    this // Возвращает "текущий" объект

Наконец, третьим типом первичных выражений являются ссылки на переменные:

                                    i // Возвращает значение переменной i
                                    sum // Возвращает значение переменной sum
                                    undefined // undefined - глобальная переменная, а не ключевое слово как null

### Инициализаторы объектов и массивов
Инициализаторы объектов и массивов – это выражения, значениями которых являются вновь созданные объекты и массивы.
Эти выражения-инициализаторы иногда называют «литералами объектов » и «литералами массивов ». Однако, в отличие от истинных литералов, они не являются первичными выражениями, потому что включают множество подвыражений, определяющих значения свойств и элементов.

В литерал массива допускается включать неопределенные элементы, для чего достаточно опустить значение между запятыми.
После последнего выражения в инициализаторах массивов допускается указывать завершающую запятую, при этом последний
элемент с неопределенным значением создаваться не будет.

                                                    > var arr = [1,,,,5];
                                                    > arr.length;
                                                    5

                                                    > var arr2 = [1, 2,];
                                                    > arr2.length;
                                                    2

имена свойств в литералах объектов могут быть строками, а не идентификаторами (это удобно, когда возникает желание
дать свойствам имена, совпадающиес зарезервированными словами, которые иначе не могут использоваться в качестве идентификаторов)

Выражение определения функции определяет функцию, а значением такого выражения является вновь созданная функция.

### Выражения обращения к свойствам
Независимо от способа обращения к свойству первым вычисляется выражение, стоящее перед . или [. Если значением
этого выражения является null или undefined, возбуждается исключение TypeError, потому что эти два значения в JavaScript не имеют свойств.

Если значение выражения не является объектом (или массивом), оно будет преобразовано в объект.

Если за первым выражением следует точка и идентификатор, интерпретатор попытается отыскать значение
свойства с именем, совпадающим с идентификатором, которое и станет значением всего выражения.

Если за первым выражением следует другое выражение в квадратных скобках, интерпретатор вычислит второе выражение
и преобразует его в строку. В этом случае значением всего выражения станет значение свойства, имя которого совпадает со строкой.

### Выражения вызова
Объекты среды выполнения также могут быть вызываемыми, даже если они не являются функциями.

### операторы
большинство операторов обозначаются символами пунктуации, такими как + и =, а некоторые – ключевыми словами, например
delete, instanceof, typeof, void.

### побочные эффекты операторов
некоторые выражения могут иметь побочные эффекты, и их вычисление может оказывать влияние на результаты последующих
вычислений. Наиболее очевидным примером являются операторы присваивания: если переменной или свойству присвоить некоторое значение, это повлияет на результат любого выражения, в котором используется эта переменная или свойство. Аналогичный побочный эффект имеют операторы инкремента ++ и декремента --, поскольку они неявно выполняют присваивание.
Оператор delete также имеет побочный эффект: операция удаления свойства напоминает присваивание свойству значения undefined. Никакие другие операторы в языке JavaScript не имеют побочных эффектов, но выражения вызова функции и создания объекта обязательно будут иметь побочные эффекты, если в теле функции или конструктора будут использованы
операторы, имеющие побочные эффекты.

### ассоциативность операторов
Ассоциативность оператора определяет порядок выполнения операций с одинаковым приоритетом. Ассоциативность слева направо означает, что операции выполняются слева направо. Например, оператор вычитания имеет ассоциативность слева
направо, поэтому следующие два выражения эквивалентны:

                                                w = x - y - z;
                                                w = ((x - y) - z);

С другой стороны, выражения

                                                w = x = y = z;

эквивалентна следующему выражению:

                                                w = (x = (y = z));

Причина в том, что операторы присваивания имеют ассоциативность справа налево.

### оператор +
соответствии с правилами преобразований оператор + отдает предпочтение операции конкатенации строк: если один из операндов является строкой или объектом, который может быть преобразован в строку, другой операнд также преобразуется
в строку, после чего выполняется операция конкатенации строк. Если ни один из операндов не является строкой, то оба операнда преобразуются в числа (или в NaN) и выполняется операция сложения.

                    1 + {}        // => "1[object Object]": конкатенация после преобразования объекта в строку
                    true + true   // => 2: сложение после преобразования логического значения в число
                    2 + null      // => 2: сложение после преобразования null в 0
                    2 + undefined // => NaN: сложение после преобразования undefined в NaN

### инкремент (++)
Значение, возвращаемое оператором ++, зависит от его положения по отношению к операнду. Если поставить его перед
операндом (префиксный оператор инкремента), то к операнду прибавляется 1, а результатом является увеличенное значение
операнда. Если же он размещается после операнда (постфиксный оператор инкремента), то к операнду прибавляется 1, однако результатом является первоначальное, неувеличенное значение операнда.

                                    var i = 1, j = ++i; // i и j содержат значение 2
                                    var i = 1, j = i++; // i содержит значение 2, j содержит значение 1

Оператор ++ никогда не выполняет операцию конкатенации строк: он всегда преобразует свой операнд в число и увеличивает
его. Если x является строкой «1», выражение ++x вернет число 2, тогда как выражение x+1 вернет строку «11».

### оператор равенства (==)
Если значения операндов имеют разные типы, он выполняет преобразование типов и пытается выполнить сравнение:
 * Если одно значение null, а другое – undefined, то они равны.
 * Если одно значение является числом, а другое – строкой, то строка преобразуется в число и выполняется сравнение с    преобразованным значением.
 * Если какое-либо значение равно true, оно преобразуется в 1 и сравнение выполняется снова. Если какое-либо значение   равно false, оно преобразуется в 0 и сравнение выполняется снова.
 * Если одно из значений является объектом, а другое – числом или строкой, объект преобразуется в простой тип и         сравнение выполняется снова.
 * Любые другие комбинации значений не являются равными.

Оператор + и операторы сравнения по-разному обрабатывают числовые и строковые операнды. Оператор + отдает предпочтение строкам: если хотя бы один из операндов является строкой, он выполняет конкатенацию
строк. Операторы сравнения отдают предпочтение числам и выполняют строковое сравнение, только когда оба операнда являются строками:

                            "11" < "3" // Строковое сравнение. Результат: true.
                            "11" < 3 // Числовое сравнение. "11" преобразуется в 11. Результат: false
                            "one" < 3 // Числовое сравнение. "one" преобразуется в NaN. Результат: false.

### оператор in
Оператор in требует, чтобы левый операнд был строкой или мог быть преобразованв строку. Правым операндом должен
быть объект. Результатом оператора будет значение true, если левое значение представляет собой имя свойства объекта,
указанного справа.

                            var point = { x:1, y:1 }; // Определить объект
                            "x" in point // => true: объект имеет свойство с именем "x"
                            "z" in point // => false: объект не имеет свойства с именем "z".
                            "toString" in point // => true: объект наследует метод toString

                            var data = [7,8,9]; // Массив с элементами 0, 1 и 2
                            "0" in data // => true: массив содержит элемент "0"
                            1 in data // => true: числа преобразуются в строки
                            3 in data // => false: нет элемента 3

### оператор instanceof
Оператор instanceof требует, чтобы левым операндом был объект, а правым – имя класса объектов. Результатом
оператора будет значение true, если объект, указанный слева, является экземпляром класса, указанного справа.
В противном случае результатом будет false.

                            var a = [1, 2, 3]; // Создать массив с помощью литерала массива 
                            a instanceof Array; // Вернет true; a – это массив
                            a instanceof Object; // Вернет true; все массивы являются объектами
                            a instanceof RegExp; // Вернет false; массивы не являются регулярными выражениями

### логическое И (&&)
если значение слева является истинным, тогда результат всего выражения определяется значением справа. Если значение
справа является истинным, значением всего выражения также должно быть истинное значение. Поэтому, когда значение слева является истинным, оператор && вычисляет и возвращает значение справа:

                               var o = { x : 1 };
                               var p = null;
                               o && o.x // => 1: o - истинное значение, поэтому возвращается o.x

### логическое ИЛИ (||)
Его работа начинается с вычисления первого операнда, выражения слева. Если значение этого операнда является
истинным, возвращается истинное значение. В противном случае оператор вычисляет второй операнд, выражение справа, и возвращает значение этого выражения.

### логическое НЕ (!)
используется для инверсии логического значения своего операнда.
оператор ! преобразует свой операнд в логическое значение перед тем, как инвертировать его. Это означает, что оператор
! всегда возвращает true или false что **всегда можно преобразовать любое значение x в его логический эквивалент, дважды применив этот оператор: !!x**

### оператор typeof

     x                  |       typeof x

undefined               |      "undefined"
null                    |      "object"
true, false             |      "boolean"
число или NaN           |      "number"
строка                  |      "string"
функция                 |      "function"
любой объект не         |      "object"
являющийся функцией     |

??? В JavaScript имеется тонкое отличие между функциями и «вызываемыми объектами»
Функции могут вызываться, но точно так же можно создать вызываемый объект – который может вызываться подобно функции,
– не являющийся настоящей функцией.

### оператор delete
Операция удаления элемента массива оставляет в массиве «дырку» и не изменяет длину массива. В результате получается разреженный массив.

                                        var a = [1,2,3]; // Создать массив
                                        delete a[2]; // Удалить последний элемент массива
                                        2 in a // => false: второй элемент больше не существует
                                        a.length // => 3

Не все свойства могут быть удалены. не могут быть удалены пользовательские переменные, объявленные с помощью
инструкции var. Кроме того, невозможно удалить функции, объявленные с помощью инструкции function, а также
объявленные параметры функций.

### оператор запятая (,)
Оператор «запятая » (,) является двухместным оператором и может принимать операнды любого типа. Он вычисляет
свой левый операнд, вычисляет свой правый операнд и возвращает значение правого операнда. То есть следующая
строка:

                                                    i=0, j=1, k=2;

вернет значение 2 и практически эквивалентна строке:

                                                    i = 0; j = 1; k = 2;

Выражение слева вычисляется всегда, но его значение отбрасывается, поэтому применять оператор запятая имеет смысл только ради побочного эффекта левого операнда.