### клиентский javascript
Объект Window центральная фигура клиентского js. Он представляет окно веб-броузера или фрейм, а сослаться
на него можно с помощью идентификатора window.

Объект Window определяет свойства такие как location, которое ссылается на объект Location, определяющий
URL текущего окна, и позволяет сценарию загружать в окно содержимое других адресов URL:

                                        // Установить значение свойства для переход на новую веб-страницу
                                        window.location = "http://www.oreilly.com/";

Кроме того,объект Window определяет методы alert() и setTimeout().

Объект Window в клиентском JavaScript является глобальным объектом. Его свойства и методы фактически являются глобальными переменными и функциями. Объект Window имеет свойство window, которое всегда ссылается на сам объект.
Это свойство можно использовать для ссылки на сам объект, но обычно в этом нет необходимости.

Одним из наиболее важных свойств объекта Window является свойство document: оно ссылается на объект Document, который
представляет содержимое документа, отображаемого в окне.

Объект Document имеет важные методы, такие как getElementById(), который возвращает единственный элемент документа,
опираясь на значение атрибута id элемента:

                                        // Отыскать элемент с атрибутом id="timestamp"
                                        var timestamp = document.getElementById("timestamp");

Объект Element, возвращаемый методом getElementById(), также имеет ряд важных свойств и методов, позволяющих сценарию
извлекать содержимое элемента, устанавливать значения его атрибутов и т.д.

                                        // Если элемент пуст, вставить в него текущую дату и время
                                        if (timestamp.firstChild == null)
                                        timestamp.appendChild(document.createTextNode(new Date().toString()));

Каждый объект Element имеет свойства style и className, позволяющие определять стили CSS элемента документа или изменять имена классов CSS, применяемых к элементу:

                                        timestamp.style.backgroundColor = "yellow";
                                        timestamp.className = "highlight";

Программы на языке JavaScript могут манипулировать содержимым документа через объект Document и содержащиеся
в нем объекты Element.

### Встраивание JavaScript-кода в разметку HTML
Клиентский JavaScript-код может встраиваться в HTML-документы четырьмя способами:
 * встроенные сценарии между парой тегов <script> и </script>;
 * из внешнего файла, заданного атрибутом src тега <script>;
 * в обработчик события, заданный в качестве значения HTML-атрибута, такого как onclick или onmouseover;
 * как тело URL-адреса, использующего специальный спецификатор псевдопротокола JavaScript.

Согласно философии программирования, известной как ненавязчивый JavaScript (unobtrusive JavaScript), содержимое
(разметка HTML) и поведение (программный код на языке JavaScript) должны быть максимально отделены друг от друга.
Следуя этой философии программирования, сценарии на языке JavaScript лучше встраивать в HTML-документы с помощью
элементов <script>, имеющих атрибут src.

Тег <script> поддерживает атрибут src, который определяет URL-адрес файла, содержащего JavaScript-код:

                                        <script src="../../scripts/util.js"></script>

Закрывающий тег </script> обязателен, даже когда указан атрибут src и между тегами отсутствует JavaScript-код.

При использовании атрибута src любое содержимое между открывающим и закрывающим тегами <script> игнорируется.

Инструменты проверки соответствия разметки требованиям стандарта HTML5 будут выдавать предупреждения, если
между тегами <script src=""> и </script> будет находиться какой-либо текст, не являющийся пробельными символами
или комментариями на языке JavaScript.

Политика общего происхождения, предотвращает возможность взаимодействия сценария на JavaScript в документе из одного
домена с содержимым из другого домена. Однако следует отметить, что источник получения самого сценария не имеет значения, значение имеет источник получения документа, в который встраивается сценарий.

Таким образом, политика общего происхождения в данном случае неприменима: JavaScript-код может взаимодействовать
с документами, в которые он встраивается, даже если этот код получен из другого источника, нежели сам документ.
Включая сценарий в свою веб-страницу с помощью атрибута src, вы предоставляете автору сценария (или веб-мастеру
домена, откуда загружается сценарий) полный контроль над своей веб-страницей.

### тип сценария
в атрибуте type указывается MIME-тип сценария:

                                                    <script type="text/vbscript">
                                                        // Здесь располагается VBScript-код
                                                    </script>

По умолчанию атрибут type получает значение text/JavaScript. При желании можно явно указать это значение, однако
в этом нет необходимости.

В старых броузерах вместо атрибута type использовался атрибут language.

Когда веб-броузер встречает элемент <script> с атрибутом type, значение которого он не может распознать, он пытается
проанализировать элемент, но не отображает и не выполняет его содержимое. Это означает, что элемент <script> можно
использовать для встраивания в документ произвольных текстовых данных: достаточно просто указать значение атрибута
type, указывающее, что данные не являются выполняемым программным кодом.

Чтобы извлечь эти данные, можно воспользоваться свойством text объекта HTMLElement, представляющего элемент script
Однако важно отметить, что такой прием встраивания данных работает только при непосредственном встраивании их в разметку. Если указать атрибут src и неизвестное значение в атрибуте type, броузер проигнорирует этот тег и ничего
не будет загружать с указанного адреса URL.

### JavaScript в URL
Еще один способ выполнения JavaScript-кода на стороне клиента – включение этого кода в URL-адресе вслед за спецификатором псевдопротокола javascript:. Этот специальный тип протокола обозначает, что тело URL-адреса представляет собою произвольный JavaScript-код, который должен быть выполнен интерпретатором JavaScript. Он интерпретируется как единственная строка, и потому инструкции в ней должны быть отделены друг от друга точками
с запятой, а для комментариев следует использовать комбинации символов /* */, а не //. «Ресурсом», который
определяется URL-адресом javascript:, является значение, возвращаемое этим программным кодом, преобразованное в строку. Если программный код возвращает значение undefined, считается, что ресурс не имеет содержимого.

URL вида javascript: можно использовать везде, где допускается указывать обычные URL: в атрибуте href тега <a>, в атрибуте action тега <form> и даже как аргумент метода, такого как window.open(). 

                                        <a href="JavaScript: new Date().toLocaleTimeString();">
                                            Который сейчас час?
                                        </a>

Если необходимо гарантировать, что URL-адрес javascript: не затрет документ, можно с помощью оператора void обеспечить
принудительный возврат значения undefined:

                                <a href="javascript:void window.open('about:blank');">Open Window</a>

Без оператора void в этом URL-адресе значение, возвращаемое методом Window.open(), было бы преобразовано в строку
и (в некоторых броузерах) текущий документ был бы затерт новым документом с текстом:

                                                            [object Window]

### Выполнение JavaScript-программ
Если веб-страница содержит встроенный фрейм (элемент <iframe>), JavaScript-код во встроенном документе будет
работать с другим глобальным объектом, отличным от глобального объекта в объемлющем документе, и его можно
рассматривать как отдельную JavaScript-программу.

Если же оба документа, вмещающий и вложенный, получены с одного сервера, то программный код в одном документе
сможет взаимодействовать с программным кодом в другом документе и их можно считать взаимодействующими частями
одной программы.

### Синхронные, асинхронные и отложенные сценарии
https://learn.javascript.ru/external-script
Если браузер видит тег <script>, то он по стандарту обязан сначала выполнить его, а потом показать оставшуюся часть страницы. Это не является проблемой для встроенных сценариев, но если сценарий находится во внешнем файле, на который ссылается атрибут src, это означает, что часть документа, следующая за сценарием, не появится в окне броузера, пока сценарий не будет загружен и выполнен.

Такой синхронный, или блокирующий, порядок выполнения действует только по умолчанию. Тег <script> может
иметь атрибуты defer и async, которые определяют иной порядок выполнения сценариев.
Согласно спецификации HTML5, эти атрибуты принимаются во внимание, только когда используются вместе с атрибутом
src:

                                            <script defer src="deferred.js"></script>
                                            <script async src="async.js"></script>

 * Атрибут async - браузер не останавливает обработку страницы, а спокойно работает дальше. Когда только будет          возможность выполнить сценарий - тогда он и выполнится

 * Атрибут defer заставляет броузер отложить выполнение сценария до момента, когда документ будет загружен, 
   проанализирован и станет готов к выполнению операций.

Но есть несколько отличий:

 * браузер гарантирует, что относительный порядок скриптов с defer будет сохранён.

То есть, в таком коде (с async) первым сработает тот скрипт, который раньше загрузится:

                                            <script src="1.js" async></script>
                                            <script src="2.js" async></script>

А в таком коде (с defer) первым сработает всегда 1.js, а скрипт 2.js, даже если загрузился раньше, будет его ждать.

                                            <script src="1.js" defer></script>
                                            <script src="2.js" defer></script>

Поэтому атрибут defer используют в тех случаях, когда второй скрипт 2.js зависит от первого 1.js, к примеру – использует что-то, описанное первым скриптом.

 * Второе отличие – скрипт с defer сработает, когда весь HTML-документ будет обработан браузером.

Например, если документ достаточно большой…

                                            <script src="async.js" async></script>
                                            <script src="defer.js" defer></script>

                                            Много много много букв

скрипт async.js выполнится, как только загрузится – возможно, до того, как весь документ готов. А defer.js подождёт готовности всего документа.

Это бывает удобно, когда мы в скрипте хотим работать с документом, и должны быть уверены, что он полностью получен.

Если тег <script> имеет оба атрибута, броузер, поддерживающий оба этих атрибута, отдаст предпочтение атрибуту async и проигнорирует атрибут defer.

теги <script> можно динамически создать и добавлять на страницу в любой момент при помощи самого javascript, заметим, что скрипты, добавленные таким образом, ведут себя так же, как async. То есть, выполняются как только загрузятся, без сохранения относительного порядка.

Если же нужно сохранить порядок выполнения, то есть добавить несколько скриптов, которые выполнятся строго один за другим, то используется свойство script.async = false.

                                        function addScript(src){
                                        var script = document.createElement('script');
                                        script.src = src;
                                        script.async = false; // чтобы гарантировать порядок
                                        document.head.appendChild(script);
                                        }

                                        addScript('1.js'); // загружаться эти скрипты начнут сразу
                                        addScript('2.js'); // выполнятся, как только загрузятся
                                        addScript('3.js'); // но, гарантированно, в порядке 1 -> 2 -> 3

