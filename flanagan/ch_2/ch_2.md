Регистрозависимый

Идентификаторы должны начинаться с буквы, символа подчеркивания(_) или $
Цифра не может быть первым символом

### Типы данных javascript:
 * числа
 * строки
 * булевы значения
 * null
 * undefined
 * object

null и undefined - единственные типы данных в языке JavaScript, которые не имеют методов.
Объекты и массивы относятся к изменяемым типам

JavaScript – это объектно-ориентированный язык программирования. В общих чертах это означает, что вместо глобальных
функций для обработки значений различных типов типы сами могут определять методы для обработки значений. Например, чтобы отсортировать элементы массива a, необязательно передавать массив a функции sort(). Вместо этого можно просто
вызвать метод sort() массива a:

                                    a.sort(); // Объектно-ориентированная версия вызова sort(a).

### Двоичное представление вещественных чисел и ошибки округления
Стандарт представления вещественных чисел IEEE-754, определяет двоичный формат их представления, 
который может обеспечить точное представление таких дробных значений, как 1/2, 1/8 и 1/1024.

Точность представления вещественных чисел в JavaScript достаточно высока и позволяет обеспечить очень близкое представление числа 0.1. Но тот факт, что это число не может быть представлено точно, может приводить к проблемам.

                                    var x = .3 - .2; // тридцать копеек минус двадцать копеек
                                    var y = .2 - .1; // двадцать копеек минус 10 копеек
                                    x == y // => false: получились два разных значения!
                                    x == .1 // => false: .3-.2 не равно .1
                                    y == .1 // => true: .2-.1 равно .1

Из-за ошибок округления разность между аппроксимациями чисел .3 и .2 оказалась не равной разности между ппроксимациями
чисел .2 и .1. Эта проблема проявляется во всех языках программирования, где используется двоичное представление вещественных чисел.


любое значение в языке JavaScript может быть преобразовано в логическое значение.
Следующие значения в результате такого преобразования дают логическое значение (и затем работают как) false: 

                                                undefined
                                                null 
                                                0
                                                -0
                                                NaN
                                                "" // пустая строка

Все остальные значения, включая все объекты (и массивы), при преобразовании дают в результате значение (и работают как) true.

                                                > typeof(null)
                                                "object"

                                                >typeof(undefined)
                                                "undefined"

Идентификатор undefined является именем предопределенной глобальной переменной (а не ключевым словом, как null), которая инициализирована значением undefined.

# Глобальный объект
Глобальный объект - обычный объект JavaScript, свойства этого объекта являются глобальными идентификаторами.
Когда выполняется запуск интерпретатора JavaScript (или когда веб-броузер загружает новую страницу), создается
новый глобальный объект, в котором инициализируется начальный набор свойств, определяющих:
 * глобальные свойства, такие как undefined, Infinity и NaN;
 * глобальные функции, такие как isNaN(), parseInt() и eval();
 * функции-конструкторы, такие как Date(), RegExp(), String(), Object() и Array()
 * глобальные объекты, такие как Math и JSON.

В клиентском JavaScript роль глобального объекта для всего JavaScript-кода, содержащегося в соответствующем
ему окне броузера, играет объект Window.

этот специальный объект может также хранить глобальные переменные программы. Если программа объявляет глобальную переменную, она становится свойством глобального объекта.

#### Объекты-обертки
Мы видели, что строки обладают свойствами и методами, но строки не являются объектами - так почему же они обладают свойствами???

**Всякий раз когда в программе предпринимается попытка обратиться к свойству строки s, интерпретатор JavaScript преобразует строковое значение в объект, как если бы был выполнен вызов new String(s). Этот объект наследует строковые методы и используется интерпретатором для доступа к свойствам. После обращения к свойству вновь созданный объект уничтожается.**

Наличие методов у числовых и логических значений объясняется теми же причинами: при обращении к какому-либо методу создается временный объект вызовом конструктора Number() или Boolean(), после чего производится вызов метода этого объекта.

Рассмотрим следующий фрагмент и подумаем, что происходит при его выполнении:

                                    var s = "test"; // Начальное строковое значение.
                                    s.len = 4; // Установить его свойство.
                                    var t = s.len; // Теперь запросить значение свойства

В начале этого фрагмента переменная t имеет значение undefined. Вторая строка создает временный объект String, устанавливает его свойство len равным 4 и затем уничтожает этот объект. Третья строка создает из оригинальной (неизмененной) строки новый объект String и пытается прочитать значение свойства len. Строки не имеют данного
свойства, поэтому выражение возвращает значение undefined. Данный фрагмент показывает, что при попытке прочитать
значение какого-либо свойства (или вызвать метод) строки числа и логические значения ведут себя подобно объектам. Но если попытаться установить значение свойства, эта попытка будет просто проигнорирована: изменение затронет только временный объект и не будет сохранено.