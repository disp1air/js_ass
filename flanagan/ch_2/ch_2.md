Регистрозависимый

Идентификаторы должны начинаться с буквы, символа подчеркивания(_) или $
Цифра не может быть первым символом

### Типы данных javascript:
 * числа
 * строки
 * булевы значения
 * null
 * undefined
 * object

null и undefined - единственные типы данных в языке JavaScript, которые не имеют методов.
Объекты и массивы относятся к изменяемым типам

JavaScript – это объектно-ориентированный язык программирования. В общих чертах это означает, что вместо глобальных
функций для обработки значений различных типов типы сами могут определять методы для обработки значений. Например, чтобы отсортировать элементы массива a, необязательно передавать массив a функции sort(). Вместо этого можно просто
вызвать метод sort() массива a:

                                    a.sort(); // Объектно-ориентированная версия вызова sort(a).

### Двоичное представление вещественных чисел и ошибки округления
Стандарт представления вещественных чисел IEEE-754, определяет двоичный формат их представления, 
который может обеспечить точное представление таких дробных значений, как 1/2, 1/8 и 1/1024.

Точность представления вещественных чисел в JavaScript достаточно высока и позволяет обеспечить очень близкое представление числа 0.1. Но тот факт, что это число не может быть представлено точно, может приводить к проблемам.

                                    var x = .3 - .2; // тридцать копеек минус двадцать копеек
                                    var y = .2 - .1; // двадцать копеек минус 10 копеек
                                    x == y // => false: получились два разных значения!
                                    x == .1 // => false: .3-.2 не равно .1
                                    y == .1 // => true: .2-.1 равно .1

Из-за ошибок округления разность между аппроксимациями чисел .3 и .2 оказалась не равной разности между ппроксимациями
чисел .2 и .1. Эта проблема проявляется во всех языках программирования, где используется двоичное представление вещественных чисел.


любое значение в языке JavaScript может быть преобразовано в логическое значение.
Следующие значения в результате такого преобразования дают логическое значение (и затем работают как) false: 

                                                undefined
                                                null 
                                                0
                                                -0
                                                NaN
                                                "" // пустая строка

Все остальные значения, включая все объекты (и массивы), при преобразовании дают в результате значение (и работают как) true.

                                                > typeof(null)
                                                "object"

                                                >typeof(undefined)
                                                "undefined"

Идентификатор undefined является именем предопределенной глобальной переменной (а не ключевым словом, как null), которая инициализирована значением undefined.

### Глобальный объект
Глобальный объект - обычный объект JavaScript, свойства этого объекта являются глобальными идентификаторами.
Когда выполняется запуск интерпретатора JavaScript (или когда веб-броузер загружает новую страницу), создается
новый глобальный объект, в котором инициализируется начальный набор свойств, определяющих:
 * глобальные свойства, такие как undefined, Infinity и NaN;
 * глобальные функции, такие как isNaN(), parseInt() и eval();
 * функции-конструкторы, такие как Date(), RegExp(), String(), Object() и Array()
 * глобальные объекты, такие как Math и JSON.

В клиентском JavaScript роль глобального объекта для всего JavaScript-кода, содержащегося в соответствующем
ему окне броузера, играет объект Window.

этот специальный объект может также хранить глобальные переменные программы. Если программа объявляет глобальную переменную, она становится свойством глобального объекта.

### Объекты-обертки
Мы видели, что строки обладают свойствами и методами, но строки не являются объектами - так почему же они обладают свойствами???

### Всякий раз когда в программе предпринимается попытка обратиться к свойству строки s, интерпретатор JavaScript преобразует строковое значение в объект, как если бы был выполнен вызов new String(s). Этот объект наследует строковые методы и используется интерпретатором для доступа к свойствам. После обращения к свойству вновь созданный объект уничтожается.

Наличие методов у числовых и логических значений объясняется теми же причинами: при обращении к какому-либо методу создается временный объект вызовом конструктора Number() или Boolean(), после чего производится вызов метода этого объекта.

Рассмотрим следующий фрагмент и подумаем, что происходит при его выполнении:

                                    var s = "test"; // Начальное строковое значение.
                                    s.len = 4; // Установить его свойство.
                                    var t = s.len; // Теперь запросить значение свойства

В начале этого фрагмента переменная t имеет значение undefined. Вторая строка создает временный объект String, устанавливает его свойство len равным 4 и затем уничтожает этот объект. Третья строка создает из оригинальной (неизмененной) строки новый объект String и пытается прочитать значение свойства len. Строки не имеют данного
свойства, поэтому выражение возвращает значение undefined. Данный фрагмент показывает, что при попытке прочитать
значение какого-либо свойства (или вызвать метод) строки числа и логические значения ведут себя подобно объектам. Но если попытаться установить значение свойства, эта попытка будет просто проигнорирована: изменение затронет только временный объект и не будет сохранено.

### Преобразование типов
Преобразование простых типов в объекты - значения простых типов преобразуются в соответствующие объекты-обертки, как если бы вызывался конструктор String(), Number() или Boolean(). Исключение составляют значения null и undefined: любая попытка использовать их в контексте, где требуется объект, вместо преобразования будет приводить к возбуждению
исключения TypeError.

### Явные преобразования типов
Простейший способ выполнить преобразование типа явно заключается в использовании функций Boolean(), Number(), String() и Object().При вызове без оператора new они действуют как функции преобразования.

                                            Number("3") // => 3
                                            String(false) // => "false" или можно использовать false.toString()
                                            Boolean([]) // => true
                                            Object(3) // => new Number(3)

Если явно попытаться преобразовать null и undefined в объект, то Функция Object() в этом случае не возбуждает исключение, вместо этого она просто возвращает новый пустой объект, в отличие от неявного преобразования которое будет приводить к возбуждению исключения TypeError.

                                            > Object(null)
                                            {}
                                            > Object(undefined)
                                            {}

Метод toString() класса Number принимает необязательный аргумент, определяющий основание системы счисления для преобразования. Если этот аргумент не определен, преобразование выполняется в десятичной системе счисления.

                                        var n = 17;
                                        binary_string = n.toString(2); // Вернет "10001"
                                        octal_string = "0" + n.toString(8); // Вернет "021"
                                        hex_string = "0x" + n.toString(16); // Вернет "0x11"

Функции parseInt() и parseFloat() - это глобальные функции, а не методы какого-либо класса. Функция parseInt() анализирует только целые числа, тогда как функция parseFloat() позволяет анализировать строки, представляющие и целые, и вещественные числа.

Обе функции пропускают начальные пробельные символы, пытаются разобрать максимально возможное количество символов числа и игнорируют все, что следует за ними. Если первый непробельный символ строки не является частью допустимого
числового литерала, эти функции возвращают значение NaN:

                                        parseInt("3 blind mice") // => 3
                                        parseFloat(" 3.14 meters") // => 3.14
                                        parseInt("-12.34") // => -12
                                        parseInt("0xFF") // => 255
                                        parseInt("0xff") // => 255
                                        parseInt("-0XFF") // => -255
                                        parseFloat(".1") // => 0.1
                                        parseInt("0.1") // => 0
                                        parseInt(".1") // => NaN: целые числа не могут начинаться с "."
                                        parseFloat("$72.47"); // => NaN: числа не могут начинаться с "$"

Функция parseInt() принимает второй необязательный аргумент, определяющий основание системы счисления для разбираемого числа. Допустимыми являются значения от 2 до 36. Например:

                                        parseInt("11", 2); // => 3 (1*2 + 1)
                                        parseInt("ff", 16); // => 255 (15*16 + 15)
                                        parseInt("zz", 36); // => 1295 (35*36 + 35)
                                        parseInt("077", 8); // => 63 (7*8 + 7)
                                        parseInt("077", 10); // => 77 (7*10 + 7)

### Преобразование объектов в простые значения.
Преобразование объектов в логические значения выполняется очень просто: все объекты (включая массивы и функции) преобразуются в значение true. Это справедливо и для объектов-оберток: результатом вызова new Boolean(false) является
объект, а не простое значение, поэтому он также преобразуется в значение true.

3.8.3. Преобразование объектов в простые значения???

### Область видимости переменной

                                    var scope = "global"; // Объявление глобальной переменной
                                    function checkscope() {
                                        var scope = "local"; // Объявление локальной переменной с тем же именем
                                        return scope; // Вернет локальное значение, а не глобальное
                                    }
                                    checkscope() // => "local"

                                    scope = "global"; // Объявление глобальной переменной, даже без var.
                                    function checkscope2() {
                                        scope = "local"; // Ой! Мы изменили глобальную переменную.
                                        myscope = "local"; // Неявно объявляется новая глоб. переменная.
                                        return [scope, myscope]; // Вернуть два значения.
                                    }
                                    checkscope2() // => ["local", "local"]: имеется побочный эффект!
                                    scope // => "local": глобальная переменная изменилась.
                                    myscope // => "local": нарушен порядок в глобальном пространстве имен.



Отличия при объявлении переменных с var и без var:

        alert(a); // undefined, понятно почему
        alert(b); // "b" is not defined

        b = 10;
        alert(b); // 10, создалось при исполнении
        
        var a = 20;
        alert(a); // 20, модифицировалось при исполнении

Ещё один важный момент относительно переменных. Переменные, в отличии от простых свойств, получают атрибут {DontDelete}, означающий невозможность удалить свойство посредством оператора delete:

        a = 10;
        alert(window.a); // 10
        alert(delete a); // true
        alert(window.a); // undefined
        
        var b = 20;
        alert(window.b); // 20
        alert(delete b); // false
        alert(window.b); // по-прежнему, 20

Эти примеры актуальны, если не используется строгий режим!!!

ReferenceError
