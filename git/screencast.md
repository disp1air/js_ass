### reset  
чтобы отменить последний коммит или несколько коммитов, выполняем git reset и передаем коммит на который нужно вернуться(можно использовать идентификатор коммита или с помощью @(HEAD) и `(тильда))

                                    git reset @`` - родитель текущего коммита  

**git reset --hard** - жесткий вариант reset - передвигает текущую ветку на указанный коммит(т.е. и HEAD тоже теперь указывает на данный коммит). Если теперь сделать изменения и закоммитать - то родителем нового коммита будет тот на который мы раньше передвинулись(т.е. с которым вызвали reset)  

Чтобы отменить этот жесткий reset - выполним git reset --hard (указатель на предыдущий коммит или ORIG_HEAD)  

По умолчанию, запись о недостижимых коммитах хранится в reflog как минимум 30 дней.  

Если в файлах были незакоммиченые изменения, то при жестком reset они пропадут - они просто будут заменены теми файлами, которые были на момент соответствующего коммита в репозитории. Эту особенность можно использовать для очистки локальной директории индекса от незакоммиченых изменений:  

                                      git reset --hard HEAD

**git reset --soft** - переносит текущую ветку на указанный коммит, но в отличие от --hard - рабочую директорию и индекс не трогает. Т.е. он отменяет последний коммит(если откатились на один коммит назад), а все файлы уже подготовлены для коммита. По сути это новый коммит, но можно взять информацию из отмененного коммита(флаг -c - если маленькая буква с - то откроется редактор, где описание можно будет поправить, а если большая(-С) то без редактирования):  

                                      git commit -С ORIG_HEAD  

флаг -с(-С) - берет не только сообщение но и данные об авторе  

git commit -C ORIG_HEAD --reset-author - такая  команда возьмет из ORIG_HEAD только сообщение.  

Отмена коммита это настолько типичная операция в git что для нее есть отдельный флаг комманды коммит --amend  

**git commit --amend** - первый шаг это исправить ошибки в рабочей директории, затем добавить обновленные файлы в индекс и дальше запустить git commit --amend.  

Эта команда делает два действия - сначала она передвинула текущую ветку назад т.е. тоже самое что и (git reset --soft @`) - при этом все файлы в рабочей директории и в индексе остались как есть - откатилась только ссылка в репозитории, а потом из текущего индекса с учетом изменений новый коммит. Причем вся информация взялась из заменяемого коммита.  


**git clean** - предназначена только для удаления неотслеживаемых файлов и директорий.  
флаги **-d** - чтобы удалялись не только флаги но и директории  
      **-dx** - чтобы удалялись в том числе файлы, которые игнорируются через .gitignore  
      **-dxf** - без него не будет работать.  

### git merge  
**git merge-base branch_1 branch_2** - укажет тот коммит где ветки branch_1 и branch_2 разделились. Т.е. общий коммити-предок для двух указанных веток.  

Дальше для каждого файла сравниваются его три версии - первая, которая была в их общем предке(base), вторая - та которая на текущей ветке(ours) и третья (theirs) - сливаемая версия. Гит берет base за основу и добавляет изменения из ours и сливаемой веток:  

                                  base + (ours changes) + (theors changes) = merge 

Гит запоминает коммит с которым мы осуществляем слияние в файле .git/MERGE_HEAD  

reset merge  

git merge --abort делает тоже самое что и git reset merge  

чтобы посмотреть что было в файле до того как ветки разделились т.е. base:  

                                  git checkout --conflict=diff3 --merge ${filename} 



-------------------------------
По умолчанию git show как и git log показывают авторскую дату. 