**Передвижение веток вручную**  
git branch - вместе с именем ветки ей можно передать коммит, тогда она создаст ветку с данным названием указывающую на него.  

git branch master 54a4 - такая команда не сработает, т.к. такая ветка уже существует, но можно указать флаг "-f"  
git branch -f master 54a4 - т.к. ветка существует то она будет перемещена. При этом необходимо уйти с ветки перед тем как менять ее.  

Для той же цели вместо git branch бывает удобно использовать git checkout -b(позволяет создать ветку с данным названием на указанном коммите и переключиться на нее - git checkout -b master 54a4)  

git checkout -B master 54a4 - то, если такая ветка уже есть, он ее передвинет, а потом переключится.  

4.6  
Допустим обнаружили, что сделали ошибку в каком-то файле, и хотим вернуть его версию которая была 2 коммита назад(или в любом другом коммите). При этом не нужно переключать ветки и все кроме этого файла нужно оставить как есть, только этот файл достать старый.  

git checkout 54a4 index.html - при указании пути(в нашем случае index.html) команда checkout не переключает ветки, а достает только указанный файл(или несколько файлов или директории) на момент переданного коммита. После этого обновится сам файл, а также востановленный файл автоматически добавляется и в Index. Т.е. теперь спокойно можно коммитать. Можно спокойно убрать его из Index(git reset index.html)  

Допустим изменили файл в рабочей директории, поэкспериментировали, но нам эти изменения не нравятся и мы хотели бы их отменить не трогая при этом остальные файлы: git checkout HEAD index.html - файл index.html теперь такой же, как последний раз сохраняли в репозитории.  

Можно было написать даже короче: git checkout index.html - при этом checkout возвращает в рабочую директорию файл из Index, в данном случае мы изменения не индексировали, так что версия файла в Index совпадает с версией в HEAD. Результат будет тот же что и выше. Но результат будет отличаться, если какие-то изменения были проиндексированы, тогда в рабочую директорию будут возвращены они.  

Т.е. checkout с путем и коммитом возвращает файл из этого коммита в рабочую директорию и Index.  
checkout только с путем возвращает его из Index в рабочую директорию.  

Допустим есть директория с названием master, но когда вызываем git checkout master как checkout поймет что мы имеем ввиду - путь master или ветку. checkout сначала пытается найти ссылку или коммит с таким идентификатором, а если нет - то предполагается что это путь. Т.к. ветка master существует, то будет выбрана она, а если хотим выбрать путь то перед путем указываем --, т.е. git checkout -- master. Все что после двойного дефиса(--) воспринимается как путь, а если есть еще какие-то флаги или аргументы, то они ставятся до него:  

git checkout HEAD -- master  

двойной дефис(--) нужен только когда возникает неопределенность.  

4.8  
Команда merge перед переносом ветки записывает старый идентификатор в файл ".git\ORIG_HEAD" и этот идентификатор можем использовать - git branch -f master ORIG_HEAD  

4.9  
git branch -d fix - удаление ветки. Удаление только ссылки fix, а сами коммиты остаются  
Удаление произойдет только если ветка объединена с текущей.  
Коммиты, которые недоступны ни по одной из ссылок называются недостижимыми и со временем они будут удалены.  

git branch -D {branch_name} - удалит ветку даже если она не была смержена.  

Недостижимые коммиты еще какое-то время сохраняются в базе, и если оказалось что ветка все еще нужна, то удаление можно отменить(создать новую ветку с таким же названием которая указывает на тот же коммит что и удаленная ветка - git branch feature 2c11)