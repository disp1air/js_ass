### Примитивные и ссылочные значения
https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions  
http://dmitrysoshnikov.com/ecmascript/ru-chapter-8-evaluation-strategy/  

Параметры функции - список идентификаторов, заданный В МОМЕНТ ОБЪЯВЛЕНИЯ. Параметры удобно рассматривать как объявления локальных переменных.  

Аргументы (входные данные) - произвольный список значений, передаваемых функции В МОМЕНТ ВЫЗОВА.  

 * Значения-примитивы передаются в функции по значению: значение КОПИРУЕТСЯ, так что если функция изменит значение параметра, это изменение не будет иметь внешнего эффекта.  

 * объекты передаются в функцию по ссылке: переприсваивание самой ссылки также не имеет внешнего эффекта, НО если функция изменяет свойства объекта, то эти изменения будут видимы вне функции (побочный эффект).

                                        function myFunc(patient) {  
                                            patient.gender= "F";  
                                        }

                                        var he = {gender: "M"};  

                                        myFunc(he);  

                                        var y = he.gender;  // y получает значение "F", упс



Доступ к примитивным переменным осуществляется по значению, то есть вы работаете с фактическим значением, хранящимся в переменной.  

Ссылочные значения - это объекты, хранящиеся в памяти. В отличие от других языков, в JavaScript невозможен прямой доступ к памяти, в том числе занимаемой объектами. Вместо этого при выполнении каких-либо действий над объектом вы на
самом деле работаете не с самим объектом, а со ссьшкой на него.

Примитивные и ссылочные значения не только хранятся, но и копируются по-разному. Когда одна переменная с примитивным значением присваивается другой, создается копия значения, хранящегося в объекте переменных, а затем она записывается
по адресу новой переменной:  

                                            var num1 = 5;  
                                            var num2 = num1;  

Здесь num1 содержит значение 5. Когда переменная num2 инициализируется значением num1, она также получает значение 5. Она никак не связана с num1, потому что содержит копию значения. Затем эти переменные можно использовать по отдельности без побочных эффектов.  

Когда ссылочное значение одной переменной присваивается другой, значение в объекте переменных также копируется в расположение новой переменной, но в этот раз оно является указателем на объект в куче. После копирования обе переменные указывают на один объект, поэтому изменения одной из них отражаются на другой.  

Все аргументы функций в E CMAScript передаются по значению. Когда аргумент передается по значению, его значение просто копируется в локальную переменную. При передаче аргумента по ссылке в локальной переменной сохраняется расположение его значения в памяти. Это означает, что изменения локальной переменной отражаются вне функции (в ECMAScript это невозможно).

                                            function setName ( obj ) {  
                                                obj.name = "Nicholas";  
                                            }    
                                                
                                            var person = new Object();  
                                            setName(person);  
                                            alert (person.name); // "Nicholas"  

В этом коде переменной person назначается созданный объект, который затем передается в функцию setName, при этом он копируется в локальную переменную obj. Внутри функции переменные obj и person указывают на один и тот же объект,
вследствие чего доступ к объекту с помощью obj выполняется по ссылке, хотя он и был передан в функцию по значению. При задании свойства name в функции это изменение отражается вне функции, потому что объект, на который указывает obj , находится в куче и доступен глобально. Многие разработчики ошибаются, когда думают, что если локальное изменение объекта проявляется глобально, значит, аргумент был передан по ссылке. Взгляните на измененный код, позволяющий
убедиться, что объекты передаются по значению:

                                            function setName (obj) {  
                                                obj.name = "Nicholas";  
                                                obj = new Object();  
                                                obj.name = "Greg";  
                                            }

                                            var person = new Object();  
                                            setName(person);  
                                            alert (person.name); // "Nicholas"

Эта функция setName() содержит две дополнительные строки кода, которые переопределяют obj как новый объект с другим именем. Когда в функцию setName() передается объект person , его свойству name присваивается значение "Nicholas".
Затем переменной obj назначается новый объект, а его свойству name присваивается значение "Greg". Если бы переменная person была передана по ссылке, она автоматически стала бы указывать на объект со свойством "Greg". Однако при выводе свойства person.name снова отображается значение "Nicholas", то есть первоначальная ссылка остается нетронутой, хотя значение аргумента внутри функции изменилось. При перезаписи переменной obj в функции она становится указателем на локальный объект, который уничтожается сразу по завершении функции.

Некоторые инструкции временно добавляют области видимости к началу цепочки, которые затем удаляются. Это
происходит в двух случаях:

 * при входе в блок catch инструкции try-catch;
 * при выполнении инструкции with.

### Сборка мусора
JavaScript - это язык со сборкой мусора, то есть за управление памятью при работе сценариев отвечает среда выполнения. Идея сборки мусора проста: нужно выяснить, какие переменные больше не потребуются, и освободить связанную
с ними память. Сборщик мусора запускается периодически с заданной частотой или в предопределенные моменты выполнения кода.

Сборщик мусора должен отслеживать, какие переменные могут потребоваться, а какие нет, чтобы можно было выявить те из них, которые допускают освобождение памяти. Способ выявления неиспользуемых переменных зависит от реализации , но в браузерах традиционно применяются две стратегии.

#### Отслеживание и очистка
Наиболее популярным способом сборки мусора в JavaScript является отслеживание и очистка ( mark-and-sweep ) . Когда переменная появляется в контексте, например при объявлении внутри функции , она помечается как находящаяся
в контексте. Память переменных в контексте не должна освобождаться, потому что они могут потребоваться, пока продолжается выполнение кода в этом контексте. Когда переменная покидает контекст, она помечается как находящаяся
вне контекста. Переменные могут помечаться разными способами - например, с помощью битапереключателя или списков переменных «В контексте» и « вне контекста». Реализация пометок не имеет значения, важен принцип. При запуске сборщика мусора он тем или иным способом маркирует все переменные, находящиеся в памяти, а затем снимает пометки со всех переменных в контексте и переменных, на которые они ссылаются. Переменные, оставшиеся помеченными после этого, считаются готовыми к удалению, потому что они недостижимы ни для каких переменных, находящихся в контексте. Затем сборщик мусора очищает память, уничтожая все помеченные переменные и возвращая связанную с ними память в среду.

#### Подсчет ссылок
Еще одним способом сборки мусора, который оказался не столь востребованным, является подсчет ссылок ( reference counting ) . Его идея в том, что каждое значение отслеживает количество ссылок на него. Когда переменная объявляется
и ей присваивается ссылочное значение, счетчик ссылок равен единице. Если это же значение присваивается другой переменной, счетчи к ссылок увеличивается, а если переменная со ссылкой на значение перезаписывается другим значением,
он уменьшается. Когда счетчик ссылок на значение достигает нуля, оно становится недоступным и занимаемую им память можно безопасно освободить, что и делает сборщик мусора при следующем запуске.

Проблема - циклические ссылки.