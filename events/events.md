Все приложения с графическим интерфейсом пользователя постоянно ожидают, пока что-то произойдет (т. е. ждут появления событий), и откликаются на происходящее.  

Объект события – это объект, связанный с определенным событием и содержащий информацию об этом событии. Объекты событий передаются функции обработчика события в виде аргумента. Все объекты событий имеют свойство type, определяющее тип события, и свойство target, определяющее цель события.  

Распространение события – это процесс, в ходе которого броузер решает, в каких объектах следует вызвать обработчики событий. В случае событий, предназначенных для единственного объекта (таких как событие «load» объекта Window), надобность в их распространении отсутствует. Однако, когда некоторое событие возникает в элементе документа, оно распространяется, или «всплывает», вверх по дереву документа. Если пользователь щелкнет мышью на гиперссылке, событие «mousemove» сначала будет возбуждено в элементе <a>, определяющем эту ссылку. Затем оно будет доставлено вмещающим элементам: возможно, элементу <p>, элементу <div> и самому объекту Document. Иногда удобнее бывает зарегистрировать единственный обработчик события в объекте Document или в другом контейнерном элементе, чем выполнять регистрацию во всех интересующих нас элементах. Обработчик события может прервать дальнейшее распространение события,
чтобы оно прекратило всплытие и не привело к вызову обработчиков вмещающих элементов. Делается это вызовом метода или установкой свойства объекта события.  

Еще одна форма распространения событий, которая называется перехватом события, позволяет специально зарегистрированным обработчикам или контейнерным элементам «перехватывать» события до того, как они достигнут фактической цели.  

Для некоторых событий предусматриваются связанные с ними действия по умолчанию. Например, для события «click», возникающего в гиперссылке, по умолчанию предусматривается операция перехода по ссылке и загрузки новой страницы. Обработчики могут предотвратить выполнение действий по умолчанию, вернув соответствующее значение, вызвав метод или установив свойство объекта события. Это иногда называют «отменой» события;  


События объекта Window представляют происшествия, имеющие отношение к самому окну броузера, а не к определенному содержимому документа, отображаемому в окне. Самым важным из этих событий является событие «load»: оно возбуждается сразу после того, как будут загружены и отображены документ и все внешние ресурсы (такие как изображения). Альтернативами событию «load» являются события «DOMContentLoaded» и «readystatechange»: они возбуждаются сразу же, как только документ и его элементы будут готовы к выполнению операций, но до того, как полностью будут
загружены внешние ресурсы.  

Событие «unload» является противоположностью событию «load»: оно возбуждается, когда пользователь покидает документ. Обработчик события «unload» можно использовать, чтобы сохранить информацию о состоянии, но в нем нельзя отменить переход на другую страницу. Событие «beforeunload» похоже на событие «unload», но оно дает возможность узнать у пользователя, действительно ли он желает покинуть вашу веб-страницу. Если обработчик события «beforeunload» вернет строку, эта строка будет выведена в диалоге подтверждения перед тем, как
будет загружена новая страница; этот диалог даст пользователю возможность отменить переход и остаться на текущей странице.  

Наконец, события «resize» и «scroll» возбуждаются в объекте Window, когда выполняется изменение размеров или прокрутка окна броузера. События «scroll» могут
также возбуждать все прокручиваемые элементы документа, например те, что имеют CSS-свойство overflow. Объект события, передаваемый обработчикам событий «resize» и «scroll», – это самый обычный объект Event, не имеющий свойств, которые позволяли бы узнать новый размер окна или величину прокрутки.  

СОБЫТИЯ МЫШИ  
События от мыши возбуждаются, когда пользователь перемещает указатель мыши или выполняет щелчок. Эти события генерируются в наиболее глубоко вложенных элементах, над которыми находится указатель мыши, но они всплывают вверх по дереву документа. Объект события, передаваемый обработчикам событий от мыши, имеет свойства, позволяющие узнать координаты указателя,
состояние кнопок мыши, а также состояние клавиш-модификаторов на момент возникновения события.  

Событие «mousemove» генерируется всякий раз, когда пользователь перемещает указатель мыши. Это событие возбуждается очень часто, поэтому его обработчики не должны выполнять тяжелые вычисления. События «mousedown» и «mouseup» генерируются, когда пользователь нажимает и отпускает кнопку мыши. Зарегистрировав обработчик события «mousedown», который регистрирует обработчик события «mousemove», можно организовать определение и обработку ситуаций буксировки элементов мышью. При этом необходимо обеспечить возможность перехватывать события от мыши, чтобы продолжать получать события «mousemove», даже когда указатель мыши выходит за пределы элемента, где была начата буксировка.  

После последовательности событий «mousedown» и «mouseup» броузер генерирует событие «click». Событие «click» было описано выше, как аппаратно-независимое событие форм, но на самом деле оно может генерироваться для любого элемента документа, а не только для элементов форм, и вместе с ним обработчику передается объект события со всеми дополнительными полями, описанными выше. Если вы дважды щелкнете мышью на строке (в течение достаточно короткого промежутка времени), второй щелчок сгенерирует событий «dblclick». Когда щелчок выполняется правой кнопкой мыши, броузеры часто выводят контекстное меню. Вообще, прежде чем вывести контекстное меню, они возбуждают событие «contextmenu», и, если отменить это событие в обработчике, можно предотвратить появление меню. Кроме того, это наиболее простой способ организовать обработку щелчка правой кнопкой мыши. 

Когда пользователь перемещает указатель мыши так, что он оказывается над другим элементом, броузер возбуждает событие «mouseover» для этого элемента. Когда указатель мыши покидает границы элемента, броузер генерирует для него событие «mouseout». Объект события для этих событий будет иметь свойство related­Target, определяющее другой элемент, вовлеченный в переход.  

Нажатия горячих комбинаций, имеющих значение для операционной системы или самого броузера, часто «съедаются» операционной системой или броузером и не передаются обработчикам событий на JavaScript. События от клавиатуры генерируются в любом элементе документа, обладающем фокусом ввода, и всплывают вверх до объектов документа и окна. Если ни один элемент не обладает фокусом ввода, события возбуждаются непосредственно в объекте документа.  


Регистрация обработчиков событий
Существует два основных способа регистрации обработчиков событий. Первый заключается в установке свойства объекта или элемента документа, являющегося целью события.
Второй способ, более новый и более универсальный, заключается в передаче обработчика методу объекта или элемента. Дело осложняется тем, что каждый прием имеет две версии. Свойство обработчика события можно установить в программном коде на языке JavaScript или в элементе документа, определив соответствующий атрибут непосредственно в разметке HTML. Регистрация обработчиков вызовом метода может быть выполнена стандартным методом с именем addEventListener() и другим методом, с именем attachEvent()  

Самый простой способ зарегистрировать обработчик события заключается в том, чтобы присвоить свойству целевого объекта события желаемую функцию обработчика. По соглашению свойства обработчиков событий имеют имена, состоящие из слова «on», за которым следует имя события: onclick, onchange, onload, onmouseover и т.д. Обратите внимание, что эти имена свойств чувствительны к регистру и в них используются только строчные символы, даже когда имя типа события состоит из нескольких слов (например «readystatechange»).  

// При­сво­ить функ­цию свой­ст­ву onload объ­ек­та Window.
// Функ­ция - об­ра­бот­чик со­бы­тия: она вы­зы­ва­ет­ся, ко­гда до­ку­мент бу­дет за­гру­жен. 
// window.onload = function() {
// Оты­скать эле­мент <form>
// var elt = document.getElementById("shipping_address");
// За­ре­ги­ст­ри­ро­вать об­ра­бот­чик со­бы­тия, ко­то­рый бу­дет вы­зы­вать­ся
// не­по­сред­ст­вен­но пе­ред от­прав­кой фор­мы.
// elt.onsubmit = function() { return validate(this); }
// }

Недостаток использования свойств обработчиков событий состоит в том, что они проектировались в предположении, что цели событий будут иметь не более одного обработчика для каждого типа событий.  


Установка атрибутов обработчиков событий
Свойства обработчиков событий в элементах документа можно также устанавливать, определяя значения атрибутов в соответствующих HTML-тегах. В этом случае значение атрибута должно быть строкой программного кода на языке JavaScript. Этот программный код должен быть не полным объявлением функции обработчика события, а только ее телом. То есть реализация обработчика события в разметке HTML не должна заключаться в фигурные скобки и предваряться ключевым словом function. Например:  

<button onclick="alert('Спасибо');">Щелк­ни­те здесь</button>

Если значение HTML-атрибута обработчика события состоит из нескольких JavaScript-инструкций, они должны отделяться точками с запятой либо значение атрибута должно располагаться в нескольких строках. Некоторые типы событий предназначены для броузера в целом, а не для какого-то конкретного элемента документа. Обработчики таких событий в языке JavaScript регистрируются в объекте Window. В разметке HTML они должны помещаться в тег <body>, но броузер зарегистрирует их в объекте Window.  

Когда в качестве значения атрибута обработчика события в разметке HTML указывается строка с программным кодом на языке JavaScript, броузер преобразует
эту строку в функцию, которая будет выглядеть примерно так:

function(event) {
  with(document) {
    with(this.form || {}) {
      with(this) {
        /* ваш про­грамм­ный код */
      }
    }
  }
}


addEventListener()  
В стандартной модели событий, поддерживаемой всеми броузерами, целью события может быть любой объект – включая объекты Window и Document и все объекты Elements элементов документа – определяющий метод с именем addEventListener(), с помощью которого можно регистрировать обработчики событий для этой цели. Метод addEventListener() принимает три аргумента. Первый – тип события, для которого регистрируется обработчик. Тип (или имя) события должен быть строкой и не должен включать префикс «on», используемый при установке свойств обработчиков событий. Вторым аргументом методу addEventListener() передается функция, которая должна вызываться при возникновении события указанного типа. В последнем аргументе методу addEventListener() передается логическое значение. Обычно в этом аргументе передается значение false. Если передать в нем значение true, функция будет зарегистрирована как перехватывающий обработчик и будет вызываться в другой фазе распространения события. Спецификация со временем может измениться так, что будет допустимо опускать третий аргумент вместо того, чтобы явно передавать
в нем значение false.  

Следующий фрагмент регистрирует два обработчика события «click» в элементе
<button>. Обратите внимание на различия двух используемых приемов:
<button id="mybutton">Щелк­ни на мне</button>
<script>
var b = document.getElementById("mybutton");
b.onclick = function() { alert("Спа­си­бо, что щелк­ну­ли на мне!"); };
b.addEventListener("click", function() { alert("Еще раз спа­си­бо!"); }, false);
</script>

Вызов метода addEventListener() со строкой «click» в первом аргументе никак не влияет на значение свойства onclick. Во фрагменте, приведенном выше, щелчок на
кнопке приведет к выводу двух диалогов alert(). Но важнее то, что метод add­EventListener() можно вызвать несколько раз и зарегистрировать с его помощью несколько функций-обработчиков для одного и того же типа события в том же самом объекте. При появлении события в объекте будут вызваны все обработчики, зарегистрированные для этого типа события, в порядке их регистрации. Многократный вызов метода addEventListener() для одного и того же объекта с теми же самыми аргументами не дает никакого эффекта – функция-обработчик регистрируется
только один раз и повторные вызовы не влияют на порядок вызова обработчиков.  

Парным к методу addEventListener() является метод removeEventListener(), который принимает те же три аргумента, но не добавляет, а удаляет функцию-обработчик из объекта. Это часто бывает удобно, когда необходимо зарегистрировать временный обработчик события, а затем удалить его в какой-то момент.  

Internet Explorer версии ниже IE9 не поддерживает методы addEventListener() и remove­EventListener(). В версии IE5 и выше определены похожие методы, attachEvent() и detachEvent().  

ВЫЗОВ ОБРАБОТЧИКОВ СОБЫТИЙ
После регистрации обработчика событий веб-броузер будет вызывать его автоматически, когда в указанном объекте будет возникать событие указанного типа. 

1. АРГУМЕНТ ОБРАБОТЧИКА СОБЫТИЙ
При вызове обработчика событий ему обычно (за одним исключением, о котором рассказывается ниже) передается объект события в виде единственного аргумента. Свойства объекта события содержат дополнительную информацию о событии. Свойство type, например, определяет тип возникшего события. В IE версии 8 и ниже обработчикам событий, зарегистрированным установкой
свойства, объект события при вызове не передается. Вместо этого объект события сохраняется в глобальной переменной window.event. Для переносимости обработчики событий можно оформлять, как показано ниже, чтобы они использовали переменную window.event при вызове без аргумента:

function handler(event) {
 event = event || window.event;
 // Здесь на­хо­дит­ся реа­ли­за­ция об­ра­бот­чи­ка
}

Объект события передается обработчикам событий, зарегистрированным с помощью метода attachEvent(), но они также могут использовать переменную window.event. В разделе 17.2.2 говорилось, что при регистрации обработчика события посредством HTML-атрибута броузер преобразует строку с программным кодом на языке JavaScript в функцию. Броузеры, отличные от IE, создают функцию с единственным аргументом event. В IE создается функция, не принимающая аргументов. Если в таких функциях использовать идентификатор event, он будет ссылаться на window.event. В любом случае обработчики событий, определяемые в разметке HTML, могут ссылаться на объект события, используя идентификатор event.  

2. КОНТЕКСТ ОБРАБОТЧИКОВ СОБЫТИЙ
Когда обработчик событий регистрируется установкой свойства, это выглядит как определение нового метода элемента документа:

e.onclick = function() { /* реа­ли­за­ция об­ра­бот­чи­ка */ };

Поэтому нет ничего удивительного, что обработчики событий вызываются (с одним исключением, касающимся IE, которое описывается ниже) как методы объектов, в которых они определены. То есть в теле обработчика событий ключевое слово this ссылается на цель события. В обработчиках ключевое слово this ссылается на целевой объект, даже когда они были зарегистрированы с помощью метода addEventListener(). Однако, к сожалению, это не относится к методу attachEvent(): обработчики, зарегистрированные с помощью метода attachEvent(), вызываются как функции, и в них ключевое слово this ссылается на глобальный (Window) объект. Эту проблему можно решить следующим способом:
/*
* Ре­ги­ст­ри­ру­ет ука­зан­ную функ­цию как об­ра­бот­чик со­бы­тий ука­зан­но­го ти­па в ука­зан­ном
* объ­ек­те. Га­ран­ти­ру­ет, что об­ра­бот­чик все­гда бу­дет вы­зы­вать­ся как ме­тод це­ле­во­го объ­ек­та.
*/
function addEvent(target, type, handler) {
 if (target.addEventListener)
 target.addEventListener(type, handler, false);
 else
 target.attachEvent("on" + type,
 function(event) {
 // Вы­звать об­ра­бот­чик как ме­тод це­ли,
 // и пе­ре­дать ему объ­ект со­бы­тия
 return handler.call(target, event);
 });
}

Обратите внимание, что обработчики событий, зарегистрированные таким способом, нельзя удалить, потому что ссылка на функцию-обертку, передаваемую методу attachEvent(), нигде не сохраняется, чтобы ее можно было передать методу detachEvent().  


ОБЛАСТЬ ВИДИМОСТИ ОБРАБОТЧИКА СОБЫТИЙ
Подобно всем функциям в языке JavaScript, обработчики событий имеют лексическую область видимости. Они выполняются в той области видимости, в какой были определены, а не в той, где они были вызваны, и имеют доступ ко всем локальным переменным в этой области видимости. (Это, например, демонстрируется в функции addEvent(), представленной выше.)
Особый случай представляют обработчики событий, которые регистрируются посредством HTML-атрибутов. Они преобразуются в функции верхнего уровня, которые не имеют доступа ни к каким локальным переменным – только к глобальным. Но по историческим причинам они выполняются в модифицированной цепочке областей видимости. Обработчики событий, определяемые посредством HTML-атрибутов, могут использовать свойства целевого объекта, объемлющего элемента <form> (если таковой имеется) и объекта Document, как если бы они были локальными переменными. В разделе 17.2.2 было показано, как из HTML-атрибута создается функция обработчика события, программный код в которой использует цепочку областей видимости, модифицированную с помощью инструкций with. HTML-атрибуты плохо подходят для включения длинных строк программного кода, и такая модифицированная цепочка областей видимости помогает сократить его. Она позволяет использовать tagName вместо this.tagName, getElementById вместо document.getElementById, а в обработчиках, привязанных к элементам документа внутри элемента <form>, можно ссылаться на другие элементы формы по значению атрибута id, используя, например, имя zipcode вместо this.form.zipcode. С другой стороны, модифицированная цепочка областей видимости обработчика событий, определяемого с помощью HTML-атрибута, может стать источником ошибок, потому что свойства всех объектов в цепочке видимости скрывают одноименные свойства глобального объекта. Например, объект Document определяет (редко используемый) метод open(), поэтому если обработчику событий, созданному с помощью HTML-атрибута, потребуется вызвать метод open() объекта Window, он
вынужден будет явно вызывать его как window.open(), вместо open(). Аналогичная (но более пагубная) проблема наблюдается при работе с формами, потому что имена и значения атрибутов id элементов формы определяют свойства во вмещающем элементе формы (раздел 15.9.1). То есть если, к примеру, форма содержит элемент со значением «location» атрибута id, все обработчики событий, созданные внутри этой формы с помощью HTML-атрибутов, должны будут использовать window.loca­tion вместо location, если им потребуется сослаться на объект Location окна.  

ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ ОБРАБОТЧИКОВ
Значение, возвращаемое обработчиком события, зарегистрированным установкой свойства объекта или с помощью HTML-атрибута, следует учитывать. Обычно возвращаемое значение false сообщает броузеру, что он не должен выполнять действия, предусмотренные для этого события по умолчанию. Например, обработчик onclick кнопки отправки формы может вернуть false, чтобы предотвратить отправку формы броузером. (Это может пригодиться, если ввод пользователя не прошел проверку на стороне клиента.) Аналогично обработчик события onkeypress поля ввода может фильтровать ввод с клавиатуры, возвращая false при вводе недопустимых символов. (Пример 17.6 фильтрует ввод с клавиатуры именно таким способом.)  

Также важно значение, возвращаемое обработчиком onbeforeunload объекта Window. Это событие генерируется, когда броузер выполняет переход на другую страницу. Если этот обработчик вернет строку, она будет выведена в модальном диалоге, предлагающем пользователю подтвердить свое желание покинуть страницу. Важно понимать, что учитываются значения, возвращаемые обработчиками
событий, только если обработчики зарегистрированы посредством установки свойств. Далее мы увидим, что обработчики, зарегистрированные с помощью addEvent­Listener() или attachEvent() вместо этого должны вызывать метод preventDefault() или устанавливать свойство returnValue объекта события.  

ПОРЯДОК ВЫЗОВА
Для элемента документа или другого объекта можно зарегистрировать более одного обработчика одного и того же типа события. При возникновении этого события броузер вызовет все обработчики в порядке, определяемом следующими правилами:
• В первую очередь вызываются обработчики, зарегистрированные установкой свойства объекта или с помощью HTML-атрибута, если таковые имеются.
• Затем вызываются обработчики, зарегистрированные с помощью метода addEvent­Listener(), в порядке их регистрации
• Обработчики, зарегистрированные с помощью метода attachEvent(), могут вызываться в произвольном порядке, поэтому ваши сценарии не должны полагаться на какой-то определенный порядок.

РАСПРОСТРАНЕНИЕ СОБЫТИЯ
Когда целью события является объект Window или какой-то другой самостоятельный объект (такой как XMLHttpRequest), броузер откликается на событие простым
вызовом соответствующего обработчика в этом объекте. Однако когда целью события является объект Document или элемент Element документа, ситуация несколько осложняется.
После вызова обработчиков событий, зарегистрированных в целевом элементе, большинство событий «всплывают» вверх по дереву DOM. В результате вызываются обработчики в родителе целевого элемента. Затем вызываются обработчики, зарегистрированные в родителе родителя целевого элемента. Так продолжается, пока не будет достигнут объект Document и затем объект Window. Способность событий всплывать обеспечивает возможность реализации альтернативы множеству обработчиков, зарегистрированных в отдельных элементах документа: можно зарегистрировать единственный обработчик в общем элементе-предке и обрабатывать события в нем. Например, вместо того чтобы регистрировать обработчик события «change» в каждом элементе формы, его можно зарегистрировать в единственном элементе <form>.  

Способностью всплывать обладает большинство событий, возникающих в элементах документа. Заметным исключением являются события «focus», «blur» и «scroll». Событие «load», возникающее в элементах, также всплывает, но оно прекращает всплывать в объекте Document и не достигает объекта Window. Событие «load» в объекте Window возбуждается, только когда будет загружен весь документ.  

Всплытие – это третья «фаза» распространения события. Вызов обработчика события в целевом объекте – это вторая фаза. Первая фаза протекает еще до вызова обработчиков целевого объекта и называется фазой «перехвата». Напомню, что метод addEventListener() имеет третий аргумент, в котором принимает логическое значение. Если передать в этом аргументе значение true, обработчик события будет зарегистрирован как перехватывающий обработчик для вызова в первой фазе распространения события. Фаза всплытия событий реализована во всех броузерах, включая IE, и в ней участвуют все обработчики, независимо от того, как они были зарегистрированы (если только они не были зарегистрированы как перехватывающие обработчики). В фазе перехвата, напротив, участвуют только обработчики, зарегистрированные с помощью метода addEventListener(), когда в третьем аргументе ему было передано значение true. Это означает, что фаза перехвата
событий недоступна в IE версии 8 и ниже, и на момент написания этих строк имела ограничения в использовании.
Фаза перехвата напоминает фазу всплытия, только событие распространяется в обратном направлении. В первую очередь вызываются перехватывающие обработчики объекта Window, затем вызываются перехватывающие обработчики объекта Document, затем обработчики объекта body и так далее, вниз по дереву DOM, пока не будут вызваны перехватывающие обработчики родителя целевого объекта. Перехватывающие обработчики, зарегистрированные в самом целевом объекте, не вызываются.  

Наличие фазы перехвата позволяет обнаруживать события еще до того, как они достигнут своей цели. Перехватывающий обработчик может использоваться для отладки или для фильтрации событий, чтобы в комплексе с приемом отмены события, описываемом ниже, предотвратить вызов обработчиков в целевом объекте. Одной из типичных областей применения фазы перехвата является реализация буксировки элементов мышью, когда событие перемещения указателя мыши должен обрабатывать буксируемый объект, а не документ, в пределах которого осуществляется буксировка.  

ОТМЕНА СОБЫТИЙ
В разделе 17.3.4 говорилось, что значение, возвращаемое обработчиком события, зарегистрированным как свойство, можно использовать для отмены действий, выполняемых броузером по умолчанию в случае этого события. В броузерах, поддерживающих метод addEventListener(), отменить выполнение действий по умолчанию можно также вызовом метода preventDefault() объекта события. Однако в IE, версии 8 и ниже, тот же эффект достигается установкой свойства returnValue объекта события в значение false. В следующем фрагменте демонстрируется обработчик вымышленного события, который использует все три способа отмены события:  

function cancelHandler(event) {
 var event = event || window.event; // Для IE
 /* Здесь вы­пол­ня­ет­ся об­ра­бот­ка со­бы­тия */
 // Те­перь от­ме­нить дей­ст­вие по умол­ча­нию, свя­зан­ное с со­бы­ти­ем
 if (event.preventDefault) event.preventDefault(); // Стан­дарт­ный при­ем
 if (event.returnValue) event.returnValue = false; // IE
 return false; // Для об­ра­бот­чи­ков, за­ре­ги­ст­ри­ро­ван­ных как свой­ст­ва
}

Текущий проект модуля «DOM Events» определяет в объекте Event свойство с именем defaultPrevented. Оно пока поддерживается не всеми броузерами, но суть его в том, что при обычных условиях оно имеет значение false и принимает значение true только в случае вызова ме­то­да preventDefault().

Отмена действий, по умолчанию связанных с событием, – это лишь одна из разновидностей отмены события. Имеется также возможность остановить распространение события. В броузерах, поддерживающих метод addEventListener(), объект события имеет метод stopPropagation(), вызов которого прерывает дальнейшее распространение события. Если в том же целевом объекте будут зарегистрированы другие обработчики этого события, то остальные обработчики все равно будут вызваны, но никакие другие обработчики событий в других объекта не будут вызваны после вызова метода stopPropagation(). Метод stopPropagation() можно вызвать в любой момент в ходе распространения события. Он действует и в фазе перехвата, и в вызове обработчика целевого объекта, и в фазе всплытия. В IE версии 8 и ниже метод stopPropagation() не поддерживается. Вместо этого объект события в IE имеет свойство cancelBubble  
