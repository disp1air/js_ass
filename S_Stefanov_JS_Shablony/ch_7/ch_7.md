## шаблоны проектирования

### шаблон единственного объекта (singleton)
Суть шаблона единственного объекта состоит в том, чтобы обеспечить возможность создать только один экземпляр определенного класса. Это означает, что при попытке создать второй экземпляр того же класса вызывающая программа должна получить объект, созданный при первой попытке.

В JavaScript объекты никогда не равны между собой, если только они не являются одним и тем же объектом, поэтому даже если создать второй такой же объект с тем же самым набором членов, он не будет тем же объектом, что и первый. Поэтому можно смело сказать, что всякий раз, когда объект создается с использованием литерала объекта, фактически создается единственный объект, и для этого не требуется использовать какие-либо специальные синтаксические конструкции.

Но в JavaScript есть оператор new, который используется для создания объектов с помощью функций-конструкторов, и иногда может потребоваться реализовать шаблон единственного объекта с помощью этого синтаксиса. Идея заключается в том, чтобы при создании нескольких объектов с помощью оператора new и одного и того же конструктора вы получали бы просто новые ссылки на один и тот же объект.

                                            var uni = new Universe();
                                            var uni2 = new Universe();
                                            uni === uni2; // true

В этом примере новый объект uni создается только при первом вызове конструктора. При втором вызове (а также третьем, четвертом и так далее) возвращается тот же самый объект uni. Именно поэтому выполняется условие uni === uni2, так как в действительности это всего лишь две ссылки, указывающие на один и тот же объект. Но как добиться этого в языке JavaScript? Для этого необходимо, чтобы конструктор Universe запоминал ссылку this на объект и затем возвращал ее при последующих вызовах. Добиться этого можно несколькими способами:

 * Ссылку на экземпляр можно сохранить в статическом свойстве конструктора. Это простое и понятное решение, но оно имеет один недостаток – свойство instance является общедоступным и может быть изменено внешним программным кодом, в результате чего есть риск потерять свой экземпляр.
 * Можно сохранить экземпляр в замыкании. Это предотвратит возможность изменения экземпляра из-за пределов     конструктора за счет создания дополнительного замыкания.

 ### Экземпляр в статическом свойстве
Ниже приводится пример сохранения единственного экземпляра в статическом свойстве конструктора Universe:

                                    function Universe() {
                                        if (typeof Universe.instance === "object") {
                                            return Universe.instance;
                                        }

                                        // создать новый экземпляр
                                        this.start_time = 0;
                                        this.bang = "Big";

                                        Universe.instance = this;
                                        // неявный возврат экземпляра:
                                        // return this;
                                    }

                                    // проверка
                                    var uni = new Universe();
                                    var uni2 = new Universe();
                                    uni === uni2; // true

### Экземпляр в замыкании
Секрет состоит в том, чтобы переопределить конструктор:

                                    function Universe() {
                                        // сохраненный экземпляр
                                        var instance = this;

                                        // создать новый экземпляр
                                        this.start_time = 0;
                                        this.bang = "Big";

                                        // переопределить конструктор
                                        Universe = function () {
                                            return instance;
                                        };
                                    }

                                    // проверка
                                    var uni = new Universe();
                                    var uni2 = new Universe();
                                    uni === uni2; // true

При первом обращении вызывается оригинальный конструктор, возвращающий ссылку this как обычно. При втором, третьем и так далее обращении вызывается уже переопределенный конструктор.
