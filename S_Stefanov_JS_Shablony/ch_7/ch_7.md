## шаблоны проектирования

### шаблон единственного объекта (singleton)
Суть шаблона единственного объекта состоит в том, чтобы обеспечить возможность создать только один экземпляр определенного класса. Это означает, что при попытке создать второй экземпляр того же класса вызывающая программа должна получить объект, созданный при первой попытке.

В JavaScript объекты никогда не равны между собой, если только они не являются одним и тем же объектом, поэтому даже если создать второй такой же объект с тем же самым набором членов, он не будет тем же объектом, что и первый. Поэтому можно смело сказать, что всякий раз, когда объект создается с использованием литерала объекта, фактически создается единственный объект, и для этого не требуется использовать какие-либо специальные синтаксические конструкции.

Но в JavaScript есть оператор new, который используется для создания объектов с помощью функций-конструкторов, и иногда может потребоваться реализовать шаблон единственного объекта с помощью этого синтаксиса. Идея заключается в том, чтобы при создании нескольких объектов с помощью оператора new и одного и того же конструктора вы получали бы просто новые ссылки на один и тот же объект.

                                            var uni = new Universe();
                                            var uni2 = new Universe();
                                            uni === uni2; // true

В этом примере новый объект uni создается только при первом вызове конструктора. При втором вызове (а также третьем, четвертом и так далее) возвращается тот же самый объект uni. Именно поэтому выполняется условие uni === uni2, так как в действительности это всего лишь две ссылки, указывающие на один и тот же объект. Но как добиться этого в языке JavaScript? Для этого необходимо, чтобы конструктор Universe запоминал ссылку this на объект и затем возвращал ее при последующих вызовах. Добиться этого можно несколькими способами:

 * Ссылку на экземпляр можно сохранить в статическом свойстве конструктора. Это простое и понятное решение, но оно имеет один недостаток – свойство instance является общедоступным и может быть изменено внешним программным кодом, в результате чего есть риск потерять свой экземпляр.
 * Можно сохранить экземпляр в замыкании. Это предотвратит возможность изменения экземпляра из-за пределов     конструктора за счет создания дополнительного замыкания.

 ### Экземпляр в статическом свойстве
Ниже приводится пример сохранения единственного экземпляра в статическом свойстве конструктора Universe:

                                    function Universe() {
                                        if (typeof Universe.instance === "object") {
                                            return Universe.instance;
                                        }

                                        // создать новый экземпляр
                                        this.start_time = 0;
                                        this.bang = "Big";

                                        Universe.instance = this;
                                        // неявный возврат экземпляра:
                                        // return this;
                                    }

                                    // проверка
                                    var uni = new Universe();
                                    var uni2 = new Universe();
                                    uni === uni2; // true

### Экземпляр в замыкании
Секрет состоит в том, чтобы переопределить конструктор:

                                    function Universe() {
                                        // сохраненный экземпляр
                                        var instance = this;

                                        // создать новый экземпляр
                                        this.start_time = 0;
                                        this.bang = "Big";

                                        // переопределить конструктор
                                        Universe = function () {
                                            return instance;
                                        };
                                    }

                                    // проверка
                                    var uni = new Universe();
                                    var uni2 = new Universe();
                                    uni === uni2; // true

При первом обращении вызывается оригинальный конструктор, возвращающий ссылку this как обычно. При втором, третьем и так далее обращении вызывается уже переопределенный конструктор.

### Фабрика
Назначение фабрики в том, чтобы создавать объекты. Этот шаблон обычно реализуется в виде классов или в виде статических методов классов и преследует следующие цели:
 * Выполнение повторяющихся операций, необходимых при создании похожих объектов
 * Предложить пользователям фабрики способ создания объектов без необходимости знать их тип (класс) на этапе компиляции



### Встроенная фабрика объектов
Встроенный глобальный конструктор Object() ведет себя, как фабрика, потому что создает различные объекты исходя из входных данных. Если передать конструктору простое число, он создаст объект, задействовав конструктор Number(). То же справедливо в отношении строк и логических значений. При любых других значениях, включая отсутствие входных значений, будут создаваться обычные объекты (конструктор Object() может вызываться как с оператором new, так и без него):

                                            var o = new Object(),
                                                n = new Object(1),
                                                s = Object("1"),
                                                b = Object(true);

                                            o.constructor === Object; // true
                                            n.constructor === Number; // true
                                            s.constructor === String; // true
                                            b.constructor === Boolean; // true

### Итератор
Шаблон итератора применяется, когда имеется объект, содержащий совокупность данных. Эти данные могут храниться в виде сложной структуры, а вам необходимо обеспечить удобный доступ к каждому элементу этой структуры. Пользователи вашего объекта не обязаны знать, как организованы ваши данные, – им необходим доступ к отдельным элементам.

Объект, реализующий шаблон итератора, должен предоставить метод next(). При последующем обращении метод next() должен вернуть следующий элемент, и только вам решать, что означает понятие «следующий» для вашей конкретной структуры данных.

### Декоратор
При использовании шаблона декораторов дополнительную функциональность можно добавлять к объекту динамически во время выполнения. В языках со статическими классами реализовать такую возможность было бы гораздо сложнее. В JavaScript
объекты допускают возможность изменения, поэтому процедура добавления функциональности в объект не представляет из себя ничего сложного.

Важной особенностью шаблона декораторов является возможность его использования для определения желаемого поведения объектов. Имея простой объект, обладающий некоторой базовой функциональностью, вы можете выбирать из множества доступных декораторов те, которыми желательно было бы расширить этот простой объект, и в каком порядке, если порядок имеет значение.