## шаблоны проектирования

### шаблон единственного объекта (singleton)
Суть шаблона единственного объекта состоит в том, чтобы обеспечить возможность создать только один экземпляр определенного класса. Это означает, что при попытке создать второй экземпляр того же класса вызывающая программа должна получить объект, созданный при первой попытке.

В JavaScript объекты никогда не равны между собой, если только они не являются одним и тем же объектом, поэтому даже если создать второй такой же объект с тем же самым набором членов, он не будет тем же объектом, что и первый. Поэтому можно смело сказать, что всякий раз, когда объект создается с использованием литерала объекта, фактически создается единственный объект, и для этого не требуется использовать какие-либо специальные синтаксические конструкции.

Но в JavaScript есть оператор new, который используется для создания объектов с помощью функций-конструкторов, и иногда может потребоваться реализовать шаблон единственного объекта с помощью этого синтаксиса. Идея заключается в том, чтобы при создании нескольких объектов с помощью оператора new и одного и того же конструктора вы получали бы просто новые ссылки на один и тот же объект.

                                            var uni = new Universe();
                                            var uni2 = new Universe();
                                            uni === uni2; // true

В этом примере новый объект uni создается только при первом вызове конструктора. При втором вызове (а также третьем, четвертом и так далее) возвращается тот же самый объект uni. Именно поэтому выполняется условие uni === uni2, так как в действительности это всего лишь две ссылки, указывающие на один и тот же объект. Но как добиться этого в языке JavaScript? Для этого необходимо, чтобы конструктор Universe запоминал ссылку this на объект и затем возвращал ее при последующих вызовах. Добиться этого можно несколькими способами:

 * Ссылку на экземпляр можно сохранить в статическом свойстве конструктора. Это простое и понятное решение, но оно имеет один недостаток – свойство instance является общедоступным и может быть изменено внешним программным кодом, в результате чего есть риск потерять свой экземпляр.
 * Можно сохранить экземпляр в замыкании. Это предотвратит возможность изменения экземпляра из-за пределов     конструктора за счет создания дополнительного замыкания.

 ### Экземпляр в статическом свойстве
Ниже приводится пример сохранения единственного экземпляра в статическом свойстве конструктора Universe:

                                    function Universe() {
                                        if (typeof Universe.instance === "object") {
                                            return Universe.instance;
                                        }

                                        // создать новый экземпляр
                                        this.start_time = 0;
                                        this.bang = "Big";

                                        Universe.instance = this;
                                        // неявный возврат экземпляра:
                                        // return this;
                                    }

                                    // проверка
                                    var uni = new Universe();
                                    var uni2 = new Universe();
                                    uni === uni2; // true

### Экземпляр в замыкании
Секрет состоит в том, чтобы переопределить конструктор:

                                    function Universe() {
                                        // сохраненный экземпляр
                                        var instance = this;

                                        // создать новый экземпляр
                                        this.start_time = 0;
                                        this.bang = "Big";

                                        // переопределить конструктор
                                        Universe = function () {
                                            return instance;
                                        };
                                    }

                                    // проверка
                                    var uni = new Universe();
                                    var uni2 = new Universe();
                                    uni === uni2; // true

При первом обращении вызывается оригинальный конструктор, возвращающий ссылку this как обычно. При втором, третьем и так далее обращении вызывается уже переопределенный конструктор.

### Фабрика
Назначение фабрики в том, чтобы создавать объекты. Этот шаблон обычно реализуется в виде классов или в виде статических методов классов и преследует следующие цели:
 * Выполнение повторяющихся операций, необходимых при создании похожих объектов
 * Предложить пользователям фабрики способ создания объектов без необходимости знать их тип (класс) на этапе компиляции



### Встроенная фабрика объектов
Встроенный глобальный конструктор Object() ведет себя, как фабрика, потому что создает различные объекты исходя из входных данных. Если передать конструктору простое число, он создаст объект, задействовав конструктор Number(). То же справедливо в отношении строк и логических значений. При любых других значениях, включая отсутствие входных значений, будут создаваться обычные объекты (конструктор Object() может вызываться как с оператором new, так и без него):

                                            var o = new Object(),
                                                n = new Object(1),
                                                s = Object("1"),
                                                b = Object(true);

                                            o.constructor === Object; // true
                                            n.constructor === Number; // true
                                            s.constructor === String; // true
                                            b.constructor === Boolean; // true

### Итератор
Шаблон итератора применяется, когда имеется объект, содержащий совокупность данных. Эти данные могут храниться в виде сложной структуры, а вам необходимо обеспечить удобный доступ к каждому элементу этой структуры. Пользователи вашего объекта не обязаны знать, как организованы ваши данные, – им необходим доступ к отдельным элементам.

Объект, реализующий шаблон итератора, должен предоставить метод next(). При последующем обращении метод next() должен вернуть следующий элемент, и только вам решать, что означает понятие «следующий» для вашей конкретной структуры данных.

### Декоратор
При использовании шаблона декораторов дополнительную функциональность можно добавлять к объекту динамически во время выполнения. В языках со статическими классами реализовать такую возможность было бы гораздо сложнее. В JavaScript
объекты допускают возможность изменения, поэтому процедура добавления функциональности в объект не представляет из себя ничего сложного.

Важной особенностью шаблона декораторов является возможность его использования для определения желаемого поведения объектов. Имея простой объект, обладающий некоторой базовой функциональностью, вы можете выбирать из множества доступных декораторов те, которыми желательно было бы расширить этот простой объект, и в каком порядке, если порядок имеет значение.

### Фасад
Фасад (façade) – простой шаблон; он только предоставляет альтернативный интерфейс для объекта. При проектировании считается хорошей практикой делать методы короткими и не выполнять в них слишком большое количество операций. Следуя такой практике, вы будете получать большее количество методов, чем в случае реализации супер методов с большим количеством параметров. Бывает, что два или более методов часто вызываются вместе. В подобных ситуациях есть смысл
создать новый метод, обертывающий повторяющуюся комбинацию вызовов других методов.

Например, для обработки событий в броузерах часто используются следующие методы:
 * stopPropagation() - используется в обработчиках событий, чтобы запретить дальнейшее всплытие события вверх по дереву DOM.
 * preventDefault() - запрещает выполнение действий, предусмотренных по умолчанию (например, переход по ссылке или отправку формы).

Это два совершенно разных метода, выполняющих разные задачи, и они должны существовать отдельно, но в то же время они часто вызываются друг за другом. Поэтому, чтобы не повторять вызовы этих двух методов снова и снова, можно создать фасадный метод, который будет вызывать их:

                                                var myevent = {
                                                    // ...
                                                    stop: function (e) {
                                                        e.preventDefault();
                                                        e.stopPropagation();
                                                    }
                                                    // ...
                                                };

### Прокси-объект
В шаблоне прокси-объекта (промежуточного объекта) один объект играет роль интерфейса другого объекта. Этот шаблон
отличается от шаблона фасада, где все, что от вас требуется, – это создать удобные методы, объединяющие в себе вызовы других методов. Промежуточный объект располагается между пользовательским программным кодом и объектом и регулирует доступ к этому объекту.

Этот шаблон может показаться излишеством, тем не менее его использование может дать прирост производительности. Промежуточный объект служит защитником основного объекта и стремится максимально уменьшить количество обращений к действительному объекту.

### Посредник (mediator)
Приложения – большие и маленькие – состоят из отдельных объектов. Все эти объекты должны взаимодействовать друг с другом способом, который не усложнял бы сопровождение программного кода и позволял бы изменять одну часть приложения, не оказывая отрицательного влияния на другую. По мере развития приложения в него добавляется все больше и больше объектов. Затем в процессе реорганизации объекты могут удаляться и перегруппировываться. Когда объекты знают
друг о друге слишком много и взаимодействуют напрямую (вызывают методы друг друга и изменяют значения свойств), это приводит к образованию нежелательной тесной связи между ними. Когда объекты слишком тесно связаны, становится сложнее изменять их так, чтобы не оказать влияния на другие объекты. Тогда внесение даже простейших изменений превращается в нетривиальную задачу, и становится практически невозможным оценить время, необходимое на внесение изменений.

Применение шаблона посредника (mediator) упрощает подобные ситуации, способствуя ослаблению связей и помогая повысить удобство сопровождения. Использование этого шаблона исключает прямые взаимодействия между независимыми объектами (коллегами) за счет введения объекта-посредника. Когда какой-либо из объектов-коллег изменяет свое состояние, он извещает об этом посредника, а посредник сообщает об изменениях всем остальным коллегам, которые должны знать об этом.