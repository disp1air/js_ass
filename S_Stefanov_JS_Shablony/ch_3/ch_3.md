У конструктора Object есть одна особенность - заключается в том, что конструктор Object() принимает параметр и в зависимости от его значения может делегировать создание объекта другому встроенному конструктору, вернув в результате объект не того типа, который вы ожидаете. В результате в каждом случае возвращаются объекты, созданные различными конструкторами:

                                    // пустой объект
                                    var o = new Object();
                                    console.log(o.constructor === Object); // true

                                    // объект-число
                                    var o = new Object(1);
                                    console.log(o.constructor === Number); // true
                                    console.log(o.toFixed(2)); // “1.00”

                                    // объект-строка
                                    var o = new Object(“I am a string”);
                                    console.log(o.constructor === String); // true

                                    // обычные объекты не имеют метода substring()
                                    // зато этот метод имеется у объектов-строк
                                    console.log(typeof o.substring); // “function”

                                    // логический объект
                                    var o = new Object(true);
                                    console.log(o.constructor === Boolean); // true

Так что лучше использовать более простую и надежную форму записи объектов в виде литералов.

Ниже приводится одна из возможных реализаций функции-конструктора Person.

                                    var Person = function (name) {
                                        this.name = name;
                                        this.say = function () {
                                            return "I am " + this.name;
                                        };
                                    };

При вызове функции-конструктора с оператором new внутри функции происходит следующее:
 - Создается пустой объект, наследующий свойства и методы прототипа функции, и ссылка на него сохраняется в переменой this.
 - Добавление новых свойств и методов в объект осуществляется с помощью ссылки this.
 - В конце функция неявно возвращает объект, на который ссылается переменная this (если явно не возвращается никакой другой объект).

Вот как примерно выглядит то, что происходит за кулисами:

                                    var Person = function (name) {
                                        // создается пустой объект с использованием литерала
                                        // var this = {};
                                        // добавляются свойства и методы
                                        this.name = name;
                                        this.say = function () {
                                            return "I am " + this.name;
                                        };
                                        // return this;
                                    };

Для простоты примера метод say() был добавлен к ссылке this. В результате при каждом вызове конструктора new Person() в памяти будет создаваться новая функция. Совершенно очевидно, что это неэкономный подход к расходованию памяти, потому что реализация метода say() не изменяется от одного экземпляра к другому. Эффективнее было бы добавить метод к прототипу функции Person:

                                    Person.prototype.say = function () {
                                        return “I am “ + this.name;
                                    };

Свойства и методы, общие для всех экземпляров, следует добавлять к прототипу.
Выше было сказано, что внутри конструктора, за кулисами, выполняется такая операция:

                                    // var this = {};

Это не совсем так, потому что «пустой» объект в действительности не является пустым – он наследует свойства и методы от прототипа функции Person. То есть точнее было бы эту операцию представить так:

                                    // var this = Object.create(Person.prototype);

### Значения, возвращаемые конструкторами
При вызове с оператором new функция-конструктор всегда возвращает объект. По умолчанию это объект, на который указывает ссылка this. Если внутри конструктора к нему не добавляются никакие свойства, возвращается «пустой» объект («пустой», если не считать свойства и методы, унаследованные от прототипа конструктора). Конструкторы неявно возвращают значение this, даже если в них отсутствует инструкция return. Однако за программистом сохраняется
возможность вернуть любой другой объект по своему выбору.

В следующем примере создается и возвращается новый объект, на который ссылается переменная that.

                                var Objectmaker = function () {
                                    // это свойство `name` будет проигнорировано,
                                    // потому что конструктор возвращает совсем другой объект
                                    this.name = "This is it";

                                    // создать и вернуть новый объект
                                    var that = {};
                                    that.name = “And that’s that”;
                                    return that;
                                };

                                // проверка
                                var o = new Objectmaker();
                                console.log(o.name); // “And that’s that”

Как видно, всегда есть возможность вернуть из конструктора любой объект при условии, что это действительно объект. Попытка вернуть что-то другое, не являющееся объектом (например, строку или логическое значение false), не будет рассматриваться как ошибка, но она будет проигнорирована, и конструктор вернет объект, на который указывает
ссылка this.