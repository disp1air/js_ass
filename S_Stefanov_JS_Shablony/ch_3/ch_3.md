У конструктора Object есть одна особенность - заключается в том, что конструктор Object() принимает параметр и в зависимости от его значения может делегировать создание объекта другому встроенному конструктору, вернув в результате объект не того типа, который вы ожидаете. В результате в каждом случае возвращаются объекты, созданные различными конструкторами:

                                    // пустой объект
                                    var o = new Object();
                                    console.log(o.constructor === Object); // true

                                    // объект-число
                                    var o = new Object(1);
                                    console.log(o.constructor === Number); // true
                                    console.log(o.toFixed(2)); // “1.00”

                                    // объект-строка
                                    var o = new Object(“I am a string”);
                                    console.log(o.constructor === String); // true

                                    // обычные объекты не имеют метода substring()
                                    // зато этот метод имеется у объектов-строк
                                    console.log(typeof o.substring); // “function”

                                    // логический объект
                                    var o = new Object(true);
                                    console.log(o.constructor === Boolean); // true

Так что лучше использовать более простую и надежную форму записи объектов в виде литералов.

Ниже приводится одна из возможных реализаций функции-конструктора Person.

                                    var Person = function (name) {
                                        this.name = name;
                                        this.say = function () {
                                            return "I am " + this.name;
                                        };
                                    };

При вызове функции-конструктора с оператором new внутри функции происходит следующее:
 - Создается пустой объект, наследующий свойства и методы прототипа функции, и ссылка на него сохраняется в переменой this.
 - Добавление новых свойств и методов в объект осуществляется с помощью ссылки this.
 - В конце функция неявно возвращает объект, на который ссылается переменная this (если явно не возвращается никакой другой объект).

Вот как примерно выглядит то, что происходит за кулисами:

                                    var Person = function (name) {
                                        // создается пустой объект с использованием литерала
                                        // var this = {};
                                        // добавляются свойства и методы
                                        this.name = name;
                                        this.say = function () {
                                            return "I am " + this.name;
                                        };
                                        // return this;
                                    };

Для простоты примера метод say() был добавлен к ссылке this. В результате при каждом вызове конструктора new Person() в памяти будет создаваться новая функция. Совершенно очевидно, что это неэкономный подход к расходованию памяти, потому что реализация метода say() не изменяется от одного экземпляра к другому. Эффективнее было бы добавить метод к прототипу функции Person:

                                    Person.prototype.say = function () {
                                        return “I am “ + this.name;
                                    };

Свойства и методы, общие для всех экземпляров, следует добавлять к прототипу.
Выше было сказано, что внутри конструктора, за кулисами, выполняется такая операция:

                                    // var this = {};

Это не совсем так, потому что «пустой» объект в действительности не является пустым – он наследует свойства и методы от прототипа функции Person. То есть точнее было бы эту операцию представить так:

                                    // var this = Object.create(Person.prototype);

### Значения, возвращаемые конструкторами
При вызове с оператором new функция-конструктор всегда возвращает объект. По умолчанию это объект, на который указывает ссылка this. Если внутри конструктора к нему не добавляются никакие свойства, возвращается «пустой» объект («пустой», если не считать свойства и методы, унаследованные от прототипа конструктора). Конструкторы неявно возвращают значение this, даже если в них отсутствует инструкция return. Однако за программистом сохраняется
возможность вернуть любой другой объект по своему выбору.

В следующем примере создается и возвращается новый объект, на который ссылается переменная that.

                                var Objectmaker = function () {
                                    // это свойство `name` будет проигнорировано,
                                    // потому что конструктор возвращает совсем другой объект
                                    this.name = "This is it";

                                    // создать и вернуть новый объект
                                    var that = {};
                                    that.name = “And that’s that”;
                                    return that;
                                };

                                // проверка
                                var o = new Objectmaker();
                                console.log(o.name); // “And that’s that”

Как видно, всегда есть возможность вернуть из конструктора любой объект при условии, что это действительно объект. Попытка вернуть что-то другое, не являющееся объектом (например, строку или логическое значение false), не будет рассматриваться как ошибка, но она будет проигнорирована, и конструктор вернет объект, на который указывает
ссылка this.

### странности конструктора Array
Когда конструктору Array() передается единственное число, оно не становится первым элементом массива. Вместо этого число нтерпретируется как размер массива. То есть вызов new Array(3) создаст массив с длиной, равной 3, но без элементов. Если попытаться обратиться к любому из элементов такого массива, вы получите значение undefined, потому
что элементы фактически отсутствуют. Следующий пример демонстрирует различия в поведении массивов, созданных с помощью литерала и конструктора с единственным значением.

                                            // массив с одним элементом
                                            var a = [3];
                                            console.log(a.length); // 1
                                            console.log(a[0]); // 3

                                            // массив с тремя элементами
                                            var a = new Array(3);
                                            console.log(a.length); // 3
                                            console.log(typeof a[0]); // “undefined”

если передать конструктору new Array() не целое число, а число с плавающей точкой. Такой вызов конструктора завершится
ошибкой, потому что число с плавающей точкой не может использоваться в качестве длины массива:

                                        var a = [3.14];
                                        console.log(a[0]); // 3.14

                                        var a = new Array(3.14); // RangeError: недопустимая длина массива
                                        console.log(typeof a); // "undefined"

При применении к массивам оператор typeof возвращает строку «object».
                                        
                                        console.log(typeof [1, 2]); // "object"

Иногда для проверки используется конструкция instanceof Array, но она дает ошибочные результаты в некоторых версиях IE.

В ECMAScript 5 определяется метод Array.isArray(), который возвращает true, если его аргумент является массивом.

                                        Array.isArray([]); // true
                                        // попытка обмануть проверку
                                        // с помощью объекта, похожего на массив
                                        Array.isArray({
                                        length: 1,
                                        “0”: 1,
                                        slice: function () {}
                                        }); // false

Если этот метод недоступен, проверку можно выполнить с помощью метода Object.prototype.toString(). Если вызвать метод call() функции toString в контексте массива, он должен вернуть строку «[object Array]». В контексте объекта этот метод должен вернуть строку «object Object]».

В литералах объектов кавычки необходимо употреблять только в том случае, если имена свойств не являются допустимыми идентификаторами, например, включают пробелы: {“first name”: “Dave”}.

Метод JSON.stringify() выполняет операцию, противоположную методу JSON.parse(). Он принимает произвольный объект или массив (или значение простого типа) и преобразует его в строку JSON:

                                    var dog = {
                                        name: “Fido”,
                                        dob: new Date(),
                                        legs: [1, 2, 3, 4]
                                    };
                                    var jsonstr = JSON.stringify(dog);
                                    // в результате будет получена строка jsonstr:
                                    // {“name”:”Fido”,”dob”:”2010-04-11T22:36:22.436Z”,”legs”:[1,2,3,4]}

