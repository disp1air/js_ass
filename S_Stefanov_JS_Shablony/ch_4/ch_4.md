### свойство name функции
function foo() {} // функция-объявление
var bar = function () {}; // функция-выражение
var baz = function baz() {}; // именованная функция-выражение

foo.name; // "foo"
bar.name; // ""
baz.name; // "baz"

### Функции обратного вызова
Если функция introduceBugs() передается как параметр функции writeCode(), это оначает, что в какой-то момент функция writeCode() выполнит (или вызовет) функцию introduceBugs(). В этом случае функция introduceBugs() называется функцией
обратного вызова:

function writeCode(callback) {
    // выполнение некоторых операций...
    callback();
    // ...
}

function introduceBugs() {
    // ... вносит ошибку
}

writeCode(introduceBugs);

При передаче introduceBugs() в виде аргумента функции writeCode() она передается без круглых скобок. Наличие круглых
скобок вызывает выполнение функции, тогда как в данном случае нам необходимо всего лишь передать ссылку на эту функцию и дать функции writeCode() возможность выполнить ее (то есть произвести обратный вызов) в нужный момент времени.

### Функции обратного вызова и их области видимости
Иногда в качестве функции обратного вызова используется не анонимная или глобальная функция, а метод объекта. Если такой метод обратного вызова использует ссылку this для обращения к своему объекту, это может стать причиной неожиданного поведения метода.

var myapp = {};
    myapp.color = "green";
    myapp.paint = function (node) {
    node.style.color = this.color;
};

var findNodes = function (callback) {
    // ...
    if (typeof callback === “function”) {
    callback(found);
    }
    // ...
};

Если теперь выполнить вызов findNodes(myapp.paint), он будет действовать не так, как ожидается, потому что свойство this.color не будет определено внутри метода. Ссылка this будет указывать на глобальный объект, потому что findNodes() – это глобальная функция. Если бы findNodes() была методом объекта с именем dom (например: dom.findNodes()), то внутри метода обратного вызова ссылка this указывала бы на объект dom, а не на объект myapp.